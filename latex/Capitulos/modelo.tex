\chapter{Un modelo en para el sistema de actores}
En este capítulo se construirá un modelo de actores utilizando \CSPm, este incluirá las funciones básicas que se comentaron previamente, tales como crear nuevos actores, enviar comunicaciones, y definir el nuevo comportamiento. 

Se empezará con un pequeño ejemplo que mostrará las ideas básicas, seguido por una descripción detallada de cada componete, algunos ejemplos de traducción de \SAL a \CSPm, terminando con una función que traduce de \SAL a \CSPm.

\section{Describiendo el sistema de actores} 
Dentro de las acciones que un actor efectúa es la de crear otro actor, en el caso de \CSP esto equivale a crear un proceso, como todos los procesos tienen que estar definidos desde el comienzo, en \CSP no existe la posibilidad de instanciar un nuevo proceso.

Para resolver este problema podemos tener todos los procesos creados al principio a la espera algún mensaje que les de inicio. Este mensaje podría verse como la palabra reservada $new$ en varios lenguajes de programación orientados a objetos. 

Para iniciar $n$ procesos de tipo $P$ utilizamos la siguiente forma:

\begin{align*}
P =& \texttt{comportmiento-de-P} \then STOP \\
P_1 =& Iniciar_1 \then P \\
P_2 =& Iniciar_2 \then P \\
&\ldots \\
P_n =& Iniciar_n \then P \\
\end{align*}

Como vimos en el capitulo anterior, \CSP es sincrónico, el paso de mensajes o envío de comunicaciones en el sistema de actores no lo es. Si queremos comunicar dos procesos en \CSP utilizamos la siguiente ecuación:

\begin{align*}
P_1 = canal!1 \then& STOP \\
P_2 = canal?x \then& STOP \\
SYSTEM = P_1 \Parallel& P_2 \\
\end{align*}


Para poder desacoplar el envío de la recepción del mensaje, una solución es utilizar una estructura intermedia de $BUFFER$, la podemos ver en la siguiente ecuación:

\begin{align*}
BUFFER =& entrada?x \then salida!x \then BUFFER \\
P_1 =& entrada!1 \then STOP \\
P_2 =& salida?x \then STOP \\
SYSTEM =& P_1 \Parallel P_2 \\
\end{align*}

Con estas estructuras, tendríamos los elementos básicos para poder crear un proceso y enviar una comunicación de manera asicronica. Lo podemos ver en la siguiente ecuación:

\begin{align*}
BUFFER =& entrada?x \then salida!x \then BUFFER\\
SUMA =& inicia_{suma} \then entrada?x \then salida?(x + 1) \then STOP \\
CLIENTE =& inicia_{suma}\then entrada!2 \then salida?x \then STOP \\
SYSTEM =& (SUMA \Parallel CLIENTE) \Parallel (BUFFER)\\
\end{align*}

El ejemplo anterior, $CLIENT$ inicia el proceso $SUMA$, y le envía un dos, este envío es desacoplado por $BUFFER$, cuando $SUMA$ recibe este dos, crea una nueva comunicación con el valor que recibió incrementado en uno.

Este simple ejemplo expone algunos de los problemas que se resolveran en este capitulo, tales como: envíar una comunicación a un proceso especifico, crear varios tipos de procesos, tener una estructura más genérica de $BUFFER$.

Otros problemas aparecen al modelarlos usando \FDR estan realacionados con como la herramienta explora los estados posibles del modelo, por ejemplo, si utilizamos el rango completo de enteros intentará revisar cada uno de estos enteros, haciendo cada exploración exponencial en cada estado que se visite.

\subsection{Estructuras de apoyo}

Antes de comenzar a enumerar las ecuaciones necesarias para las operaciones básicas utilizando acotres, se enunciaran algunas estructuras necesarias para construir estas funcionalidades.

\subsubsection{Enteros pequeños}

Para evitar la explosión de estados que causa utilizar el rango de enteros de 64-bits, se generó una una representación propia para reducir esta explisión. El valor $MAX\_INT$ es el entero mas grande que se quisiera representar.

\begin{align*}
datatype\ SmallInt =&\ SI.\{0 \ldots MAX\_INT\} | Overflow \\
\\
add(SI.a, SI.b)\ =&\ let\ sum\ = a + b \\
&within\ if\ sum <= MAX\_INT\ then\ SI.sum\ else\ Overflow  \\
%
sub(SI.a, SI.b) =&\ let\ sub\ =\ a - b \\
& within\ if\ sub >= 0\ then\ SI.sub\ else\ Overflow \\
%
mult(SI.a, SI.b) =&\ let\ mult\ = a * b \\
& within\ if\ mult <= MAX\_INT\ then\ SI.mult\ else\ Overflow \\
eq(SI.a, SI.b)\ =&\ a == b \\
eq(\_, \_)\ =&\ false
\end{align*}

\subsubsection{Identificadores de actores}

Esta construcción nombra cada uno de los actores que van ser utilizados, también guarda la cantidad de actores de un tipo dado. Esto se verá en detalle más adelante.

Para la definición usa tipos algebraicos similares a los de Haskell soportados por \CSPm.

\begin{figure}[H]
\begin{align*}
  datatype\ ActorID &= ACTOR_1.\{1 \ldots N_1\} | \\
  & ACTOR_2.\{1, \ldots ,N_2\} | \\
  & ACTOR_k.\{1, \ldots, N_k\} | \\
  & Main.\{1\}
\end{align*}
\end{figure}

Ya que no existe en \CSP el concepto de instancia es necesario contar con todos los procesos que van a ser parte de la red definidos desde el principio, el valor que está entre llaves corresponde a la cantidad de actores de este tipo que van a ser necesarios. 

\subsubsection{Valores primitivos}

Representaremos las cadenas de caracteres utilizando $Atoms$, estas cadenas son inmutables y la única operacion que se efectua sobre ellas es la comparación.

\[
  datatype\ Atoms = ATOM_1 | ATOM_2 | \ldots | ATOM_n
\]

$VALUE$ es un tipo de datos que nos permite tener cierta flexibilidad al momento de enviar mensajes o crear actores. 

\[
  datatype\ VALUE = ACTOR.ActorID | INT.SmallInt | ATOM.Atoms | None
\]

\subsection{Buzón} 

Recodemos que la naturaleza de \CSP es sincronica y los actores no lo son para esto necesitamos desacoplar el envío de mensajes de la recepción. Para esto utilizamos una estructura intermedia que actúa de \textit{buzón}, y dos canales que sirven para comunicarse con ella.

La ecuación de \textit{buzón} es la siguiente:

\begin{process}
\begin{block}
Mailbox(i, \nil) = {} \\ \quad
CommSend?i.x \then Mailbox(i, \lseq x \rseq) 
\end{block} \\

\begin{block}
Mailbox(i, \lseq x \rseq) = {} \\ \quad 
  \begin{block}
    CommRecv!i.x \then Mailbox(i, \nil) \\
    \Extchoice \\
    CommSend?i.y \then Mailbox(i, \lseq x, y \rseq) 
  \end{block}
\end{block} \\

\begin{block}
Mailbox(i, \lseq x, y \rseq) = {} \\ \quad
  \begin{block}
    CommRecv!i.x \then Mailbox(i, \lseq y \rseq) \\
    \Extchoice \\
    CommRecv!i.y \then Mailbox(i, \lseq x \rseq) 
  \end{block} 
\end{block}

\end{process}

Donde $Mailbox(i, \nil)$ es cuando \textit{buzon} está vacio, $Mailbox(i, \lseq x \rseq)$ es cuando tiene al menos un mensaje, $Mailbox(i, \lseq x, y \rseq)$ es cuando tiene su capacidad completa.

Los canales para comunicarse con el búzon se definen de la siguiente forma:

\[
channel\ CommSend:ActorID.(VALUE, VALUE)\\
channel\ CommRecv:ActorID.(VALUE, VALUE)
\]

Un \textit{buzón} puede guardar más de una comunicación en su interior. Esto introduce un tipo de no determinismo ya que un actor puede sincronizar con cualquiera de las comunicaciones disponibles en su \textit{buzón}.

El comportamiento del proceso buzón depende de su estado, si no tiene ningún mensaje, si tiene algunos mensajes, o si está completo. Podríamos modelar un buzón que no tenga una cota superior, pero tendríamos problemas de explosión de estados ya que \FDR intentaría explorar todas las convinaciónes posibles de buzón.

\begin{itemize}
\item Si no tiene ningún mensaje, solo sincroniza mensajes por el canal $CommSend$.
\item Si tiene algunos mensajes, por los canales $CommSend$ y $CommRecv$.
\item Si está completo, solo por el canal $CommRecv$.
\end{itemize}

Puede que los nombre de los canales suenen poco intuitivos, es importante notar que provienen de la acciones vista desde los actores.

\begin{description}
\item [CommSend] canal utilizado para comunicar desde cualquier actor hacia el buzón.
\item [CommRecv] canal utilizado para comunicar del buzón hacia el actor asociado.
\end{description}

Por cada actor en la red, existe un \textit{buzón} con el mismo $ActorID$ asociado. Para esto utilizamos la siguiente ecuación:

\[
Mailboxes = \Interleave_{actor : \{| ActorID |\} } Mailbox(actor, \nil) 
\]

$Mailboxes$ representa todos los buzones puestos en paralelo utilizando el operador \textit{Interleave}. Como no existe comunicación entre buzones, siempre la comunicación es desde un actor hacia un buzón es que se elige el operador de \textit{Interleave}.

\subsection{Crear nuevos actores}\label{modelo:crear}

Como se menciono en las seccione anteriores, en \CSP no existe el concepto de instancia, y debemos tener definida la red de procesos desde el comienzo. Para resolver este problema, se presentan dos abstracciones.

La primera abstracción es un preámbulo a un comportamiento, le asigna a este de los parámetros \textit{acquaiantence-list} y al mismo tiempo el otorga al actor su identificador único de \textit{buzón}. Utilizamos para esto un proceso que funciona como una maquina de actores y un canal para comunicarse con ella.

La maquina de actores se define de la siguiente forma:

\begin{align*}
actors\_machine_k = \Interleave_{ self : \{| ACTOR_k |\} } & Create!self?(p1, p2) \then \\
& comportamiento_k(self, p1, p2) 
\end{align*}

Donde $actors\_machine_k$ hace referencia a la maquina de actores del $comportamiento_k$; $self : \{| ACTOR_k |\}$ es el conjunto de todos los actor $ActorID$ disponibles para $ACTOR_k$, $Create!self?(p1, p2)$, sincroniza en el canal $Create$ envía $self$ como parametro y recibe $(p1, p2)$; $comportamiento_k(self, p1, p2)$ llama al proceso parametrizado definido como $comportamiento_k$ con los parametros $self$, $p1$ y $p2$.

El canal para comunicarse con la maquina de actores se define de la siguiente forma:

\[
channel\ Create:ActorID.(VALUE, VALUE)
\]

En realidad, la creación es algo ficticio, ya que tenemos una red de procesos \CSP esperando al evento $Create$ para arrancar con el comportamiento definido. 

El conjunto definido por $ACTOR_k$ es equivalente a los elementos definidos en $ActorID$. Por esto es que decimos que no solo define el nombre, sino que al mismo tiempo está estableciendo cuantos actores del tipo $ACTOR_k$ vamos a tener.

Siguiendo con esta idea, $actors_machine_k$, representa todos los actores que van ser iniciados en paralelo utilizando el operador de \textit{Interleave}. Una vez sincronizado en el mensaje $Create$, se ejecuta el comportamiento que obtiene el identificador del buzón y los parámetros recibidos.

La segunda abstracción es un proceso que desacopla el mensaje de creacion, de la creación como tal. Para esto se utiliza una estructura intermedia $create$ y un canal para comunicarse con ella. $create$ se define de la siguiente forma: 

\[
\begin{array}{l}
create(actorId) = CreateAsk!actorId?m \then Create.actorId!m \then STOP \\
creates = \Interleave_{actor : ActorID} create(actor)
\end{array}
\]

Donde $create(actorId)$ es un proceso parametrizado; $CreateAsk!actorId?m$ sincroniza en el canal $CreateAsk$ envía $actorId$ y recibe la lista de valores $m$. $\Interleave_{actor : ActorID}$ pone en paralelo todos los actores definidos en $ActorId$ utilizando $create$

El canal que para comunicarse con esta estructura se define:

\[
channel\ CreateAsk:ActorID.(VALUE, VALUE)
\]

Como puede observarse, tenemos tantos procesos en paralelo como $ActorID$ existan. Tal vez esta abstracción podría haber sido omitida, pero juega un papel fundamental en la construcción total del sistema, esto tiene que ver con en \CSP se puede elegir los eventos \cite[chap.~2,p.~55]{Roscoe:1997:TPC:550448} que se van a sincronizar, cuando veamos como compone todo el sistema esta idea quedará mas clara.

\subsection{Definición de comportamientos}
La idea de comportamiento fue introducida en la sección \ref{actores:comportamientos}, podemos pensar a un comportamiento como una función que procesa una comunicación y tiene como salida, nuevas comunicaciones, nuevos actores y el comportamiento de reemplazo para el actor que esta procesando la comunicación.

\begin{align*}
&CommSend.aid!(p_1, p_2) & (Enviar\ Comunicaciones) \\ 
&CreateAsk!Actor_m.aid?(p_1, p_2) & (Crear\ nuevos\ actores)\\
&comportamiento_k(self, p_1, p_2)  & (Comportamiento\ de\ reemplazo)
\end{align*}

\begin{description}
\item [Enviar Comunicaciones] En este caso le enviaremos al actor con buzón $actor_n$ la lista $(p_1, p_2)$. 
\item [Crear nuevos actores] Obtendríamos mediante $Actor_m.aid$ el identificador de buzón del actor creado, y le enviaríamos los parámetros $(p_1, p_2)$ como \textit{acquaiantence-list}.
\item [Comportamiento de reemplazo] En este caso el comportamiento sería $comportamiento_k$. De no contar con uno sería simplemente STOP.
\end{description}

\subsection{Ejemplo: cálculo de factorial en CSPm}
En esta seccion se describira el funcionamiento de factorial, guarda cierta similitud con el ejemplo antes visto en sal \SAL. Está compuesto por dos comportamientos $Factorial$ y $FactorialWorker$.

Continuando con la mecanica al capitulo anterior, primero se mostrara codigo en \CSPm, luego se comentaran las lineas de interes, para terminar con un pequeño detalle del funcionamiento.

El primero de los comportamientos, es el de $Factorial$ que viene dado por la siguiente forma:
\begin{process}
Factorial(self) = {} \\ \quad
  \begin{block}
  CommRecv?self.(ACTOR.mailboxClient, INT.k) \then {} \\ \quad
    \begin{block}
    \If (eq(k,SI.0)) \Then {} \\ \quad
      \begin{block} 
      CommSend!mailboxClient.(INT.SI.1, None) \then \\
      Factorial(self) 
      \end{block} \\
    \Else {} \\ \quad
      \begin{block}
      \begin{declaration}
     m  = sub(k, SI.1) 
	\end{declaration} \\
	\begin{within}
	CreateAsk?factorialWorker.pid!(INT.k, ACTOR.mailboxClient) \then \\
	CommSend!self.(ACTOR.factorialWorker.pid, INT.m) \then \\
	Factorial(self)
	\end{within}
      \end{block}
    \end{block}
  \end{block}
\end{process}


\begin{description}
 \item $CommRecv?self.(ACTOR.mailboxClient, INT.k)$ espera recibir una comunicación con los parametros de tipo, el primero buzón y el segundo un entero.
 \item $\If (eq(k,SI.0))$ Compara el entero $k$, con cero utilizando la definición de enteros pequeños antes vista.
 \item $CommSend!mailboxClient.(INT.SI.1, None)$ envia una comunicación al buzón $mailboxClient$ la lista con el valor $1$ y $None$. En este caso $None$ es solo un marcador de posición.
 \item $CreateAsk?factorialWorker.pid!(INT.k, ACTOR.mailboxClient)$ crea un nuevo actor de tipo $FactorialWorker$, guarda en $pid$ la direción del buzón. Inicializa los valors \textit{acquaiantence-list} con el entero $k$ y el buzón $mailboxClient$.
 \item $CommSend!self.(ACTOR.factorialWorker.pid, INT.m)$ Se auto envía un mensaje, con el valor de buzón del actor creado en la linea anterior, y el entero $m$, que fue calculado utilizando $m  = sub(k, SI.1)$. Esta ultima operación es la resta para enteros pequeños.
 \item $Factorial(self)$ define como siguiente comportamiento, $Factorial$ para el buzón $self$.
\end{description}

Cuando recibe un entero distinto de cero ejecuta dos acciones, crea un actor \textbf{FactorialWorker} y se envía un mensaje a si mismo para evaluar el factorial de \textbf{n - 1}. En este caso el comportamiento de reemplazo para el buzón actual no cambia. Para una descripción mas detallada revisar la sección \ref{sal:factorial}

El segundo de los comportamientos, es el de $FactorialWorker$ que viene dado de la siguiente forma:

\begin{process}
FactorialWorker(self, INT.k, ACTOR.mailboxClient) = {} \\ \quad
  \begin{block}
  CommRecv.self?(INT.n, None) \then {} \\ \quad
    \begin{block}
    \begin{declaration}
    val = mult(n, k) 
    \end{declaration} \\
    \begin{within}
    CommSend.mailboxClient!(INT.val, None) \then \\
    STOP
    \end{within}
    \end{block}
  \end{block}
\end{process}

\begin{description}
 \item $CommRecv.self?(INT.n, None)$ Espera una comunicación que contenga un entero, y lo guarda en $n$.
 \item $val = mult(n, k)$ utiliza la multiplicación de enteros pequeños, guarda en $val$ la multiplicación de $n * k$.
 \item $CommSend.mailboxClient!(INT.val, None)$ envía el el valor antes calculado a la dirección de buzón $mailboxClient$
\end{description}

Este comportamiento es muy simple, en el momento de creación recibe dos parámetros, un entero $k$ y un dirección de un buzón. Al momento de recibir una comunicación, efectúa la multiplicación del valor recibido por $k$ y se lo envía a $mailboxClient$.

En este caso no cuenta con comportamiento de reemplazo, entonces termina con $STOP$.

Tanto para $Factorial$ y para $FactorialWorker$ faltan definir ambas maquinas de actores definidas en la sección  \cite{modelo:crear}. El ejemplo entero puede verse en el \textbf{apendiceXXXinsertarApendice}.


\subsection{Ejemplo: Una pila}

En este ejemplo se construiriá una estructura de datos de tipo \textbf{pila}, la cual esta compuesta de un solo comportamiento $node$ que es el que se encarga de recibir las operaciones $PUSH$ y $POP$. En este caso se agrega al modelo $fwd$ que como veremos, está encargado de modelar el comportamiento $\textbf{become}\ buzon$.

El comportamiento de $fwd$ está definido de la siguiente forma:

\[
  fwd(a, b) = CommRecv.a?msg \then CommSend.b!msg \then fwd(a, b)
\]

El proceso anterior, reenvia todas las comunicaciones desde el buzón de $a$, al buzón de $b$.

El comportamiento de $node$ está definido de la siguiente forma:

\begin{process}
comportamiento_{node}(self, content, link) = {} \\ \quad
\begin{block}
CommRecv.self?(ATOM.PUSH, newContent) \then \\
CreateAsk?Node.newNode!(content, ACTOR.link) \then \\
comportamiento_{node}(self, newContent, Node.newNode)
\end{block} \\
\Extchoice \\ \quad
\begin{block}
CommRecv.self?(ATOM.POP, ACTOR.client) \then  \\
CommSend.client!(content, None) \then  \\
fwd(self, link)
\end{block}

\end{process}

\begin{description}
 \item $CommRecv.self?(ATOM.PUSH, newContent)$ espera recibir un mensaje, donde el primer elemento de la lista sea la constante $ATOM.PUSH$, guarda en $newContent$ el valor del segundo elemento de la lista.
 \item $CreateAsk?Node.newNode!(content, ACTOR.link)$ crea un actor de un tipo $Node$ y guarda en $newNode$ el valor de la dirección del buzón. Inicializa los valors \textit{acquaiantence-list} con valor $content$ y el buzón $link$.
 \item $comportamiento_{node}(self, newContent, Node.newNode)$ define como comportamiento para el buzón $self$, el mismo comportamiento con los parametros, $newContent$ y el buzón creado en la linea anterior.
 \item $CommRecv.self?(ATOM.POP, ACTOR.client)$ espera recibir un mensaje, donde el primer elemento de la lista sea la constante $ATOM.POP$, guarda en $client$ el valor del segundo elemento de la lista.
 \item $CommSend.client!(content, None)$ envía una comunicación al buzón $client$ la lista con el valor $content$ y $None$. En este caso $None$ es solo un marcador de posición.
 \item $fwd(self, link)$ se comporta como el proceso $fwd$. 
\end{description}

Cuando la operación es de tipo $pop$, se envía el valor que contiene el nodo al buzón $client$ y se reenvían todos los mensajes a $link$, todas las futuras operaciones $push$ y $pop$ las recibe este nodo.

Cuando la operación es de tipo $push$, la pila crea un nuevo actor $node$. Se copia en $Node.newNode$ el nodo actual, y se reemplaza el contenido del nodo actual con el contenido recibido. Esto puede verse como el reemplazo de la cabeza de la pila.

\subsection{Ejemplo: Un una cola}

En este ejemplo se explorará como construir una estructura de datos de tipo \textit{cola}, se intentó modelarla como si fuera una máquina de estados, dónde cada comportamiento corresponde a un estado y las comunicaciones son quienes disparan las transiciones de estos. Primero se mostrará el ejemplo escrito utilizando \SAL, y luego su equivalente en \CSPm.

Existen dos operaciones posibles para efecturse en una cola \textit{cola} $QUEUE$ o encolar, y $DEQUEUE$ desencolar. La primera operación agrega un nodo al final, y la segunda lo remueve del principio.

Tanto el ejemplo en \SAL como el de \CSPm tienen cuatro comportamientos:

\begin{description}
 \item [node] Guarda contentido y una referencia al siguiente nodo en la \textit{cola}.
 \item [queue] La estructura de datos propiamente, tiene referencia a dos nodos, el primero y el último.
 \item [emptyQueue] Este es el compotamiento es cuando la \textit{cola} no tiene ningún nodo en ella.
 \item [waitDelete] Un estado transicional, es utilizado cuando se elimina un nodo de la \textit{cola}.
\end{description}

En el resto de la sección se detallaran cada uno de los cuatro comportamientos antes enumerados, para terminar con una descripcion de como estos funcionan en conjunto.

\subsubsection*{Comportamiento de node}

\begin{lstlisting}[language=sal, style=simple]
def node(content, link)[]
  if operation = delete then
    send [content, link] to mailbox
  end if
  if operation = insert then
    become node(content, mailbox);
  end if
end def
\end{lstlisting}

\begin{description}
 \item [Lineas 2-4] Si la operación es $delete$, envía su contenido a mailbox. Como no hay comportamiento de reemplazo, este nodo termina su ejecución en este momento.
 \item [Lineas 5-7] Si la operación es $insert$, el comportamiento de reemplazo tiene un nuevo nodo al que apunta. Esta operación basícamente cambia, cambia el nodo que está proxímo en la \textit{cola}.
\end{description}

\begin{process}
Node(self, content, link) = \\ \quad
  \begin{block}
  CommRecv.self?(ATOM.DELETE, ACTOR.mailbox) \then \\
  CommSend.mailbox!(link, content) \then \\
  STOP
  \end{block} \\

  \Extchoice \\ \quad
  
  \begin{block}
  CommRecv.self?(ATOM.INSERT, mailbox) \then \\
  Node(self, content, mailbox)
  \end{block}
\end{process}

\begin{description}
 \item $CommRecv.self?(ATOM.DELETE, ACTOR.mailbox)$ espera recibir un mensaje, donde el primer elemento de la lista sea la constante $ATOM.DELETE$, guarda en $mailbox$ el valor del segundo elemento de la lista, que es de tipo $ACTOR$.
 \item $CommSend.mailbox!(link, content)$ Envía una comunicación al buzón $mailbox$, con la lista $link$ y $content$
 \item $STOP$ como no hay comportamiento de reemplazo, el actor termina su ejecución.
 \item $CommRecv.self?(ATOM.INSERT, ACTOR.mailbox)$ espera recibir un mensaje, donde el primer elemento de la lista sea la constante $ATOM.INSERT$, guarda en $mailbox$ el valor del segundo elemento de la lista, que es de tipo $ACTOR$.
 \item $Node(self, content, mailbox)$ Define el comportamiento de reemplazo, utiliza el parametro $mailbox$ recibido en el linea como reemplazo del anterior $link$.
\end{description}

\subsubsection*{Comportamiento de emptyQueue}

\begin{lstlisting}[language=sal, style=simple]
def emptyQueue()[operation, value]
  if operation = enqueue then
    let P = new node(value, nil) in
      become queue(P, P)
  end if
end def
\end{lstlisting}

\begin{description}
 \item [Linea 3] Si la operacion fue $enqueue$, entonces crea un nuevo nodo con el valor recibido. Como es el primer nodo que va a tener la cola, el parametro del siguiente nodo en la pila es $nil$. 
 \item [Linea 4] El comportamiento de reemplazo para este actor, es $queue$ donde el primer y el ultimo actor es el actor creado en la linea anterior.
\end{description}

\begin{process}
EmptyQueue(self) = \\ \quad
  \begin{block}
  CommRecv.self?(ATOM.ENQUEUE, INT.value) \then \\ 
  CreateAsk?node.pid!(INT.value, ACTOR.NoId) \then \\
  Queue(self, ACTOR.node.pid, ACTOR.node.pid)
  \end{block}
\end{process}

\begin{description}
 \item $CommRecv.self?(ATOM.ENQUEUE, INT.value)$ espera recibir un mensaje, donde el primer elemento de la lista sea la constante $ATOM.ENQUEUE$, guarda en value el valor del segundo elemento de la lista, que es de tipo $INT$.
 \item $CreateAsk?node.pid!(INT.value, ACTOR.NoId)$ crea un nuevo actor de tipo $node$, guarda en en $pid$ el buzón. Inicializa los valores \textit{acquaiantence-list} con el entero $value$ y el buzón nulo $NoId$.
 \item $Queue(self, ACTOR.node.pid, ACTOR.node.pid)$ Define a $Queue$ como el comportamiento de reemplazo, para el buzón $self$. Le pasa como parametro la dirección del buzón del actor antes creado, se repite por que tanto el primer como el ultimo nodo es el mismo cuando la \textit{cola} tiene un solo nodo.
\end{description}

\subsubsection*{Comportamiento de queue}

\begin{lstlisting}[language=sal, style=simple]
def queue(first, last)[operation, value, client]
  if operation = enqueue then
    let P = new node(value, nil) in
      send [insert, P] to last
      become queue(first, P)
  end if
  if operation = dequeue then
    send [delete, self] to first
    become waitDelete(last, client)
  end if
end def
\end{lstlisting}

\begin{description}
 \item [Linea 1] $first$ y $last$ son respectivamente, el primer y último nodo de la \textit{cola}.
 \item [Linea 3] Si la operacion fue $enqueue$, entonces crea un nuevo nodo con el valor recibido. 
 \item [Linea 4] Le envía un mensaje a $last$ para que intercambie el valor al que apunta por el valor del nodo recien creado.
 \item [Linea 5] El comportamiento de reemplazo es el mismo, lo único que cambia es el valor del buzón del último nodo ($last$) por el nodo recien creado.
 \item [Linea 8] Borra el primer nodo en la lista.
 \item [Linea 9] El nuevo comportamiento es un estado intermedio llamado $waitDelete$.
\end{description}


\begin{process}
Queue(self, ACTOR.first, ACTOR.last) = \\ \quad
  \begin{block}
  CommRecv.self?(ATOM.ENQUEUE, value) \then \\
  CreateAsk?Node.newLast!(value, ACTOR.NoId) \then \\
  CommSend.first!(ATOM.INSERT, ACTOR.Node.newLast) \then \\
  Queue(self, ACTOR.first, ACTOR.Node.newLast)
  \end{block} \\

  \Extchoice \\ \quad
  
  \begin{block}
  CommRecv.self?(ATOM.DEQUEUE, ACTOR.client) \then \\
  CommSend.first!(ATOM.DELETE, ACTOR.self) \then \\
  CommSend.client!(INT.value, None) \then \\ 
  WaitDelete(self, client, last)
  \end{block} 
\end{process}


\begin{description}
 \item $CommRecv.self?(ATOM.ENQUEUE, value)$ espera recibir un mensaje, donde el primer elemento de la lista sea la constante $ATOM.ENQUEUE$, guarda en value el valor del segundo elemento de la lista, que es de tipo $INT$.
 \item $CreateAsk?node.pid!(INT.value, ACTOR.NoId)$ crea un nuevo actor de tipo $node$, guarda en en $newLast$ el buzón. Inicializa los valores \textit{acquaiantence-list} con el entero $value$ y el buzón nulo $NoId$.
 \item $CommSend.first!(ATOM.INSERT, ACTOR.node.newLast)$ Envía una comunicación al buzón $first$, con la lista $ATOM.INSERT$ y el actor creado en la linea anterior $newLast$. 
 \item $Queue(self, ACTOR.first, ACTOR.Node.newLast)$ Define a $Queue$ como el comportamiento de reemplazo, para el buzón $self$. Pasa como parametro la dirección del buzón del actor antes creado como reemplazo del ultimo nodo de la pila.
 \item $CommRecv.self?(ATOM.DEQUEUE, value)$ espera recibir un mensaje, donde el primer elemento de la lista sea la constante $ATOM.DEQUEUE$, guarda en value el valor del segundo elemento de la lista, que es de tipo $ACTOR$.
 \item $CommSend.first!(ATOM.DELETE, ACTOR.self)$ Envía una comunicación al buzón $first$, con la lista $ATOM.DELETE$ y la dirección del buzón de la actor \textit{cola}. 
 \item $CommSend.client!(INT.value, None)$ envía una comunicación al buzón $client$ la lista con el valor $value$ y $None$. En este caso $None$ es solo un marcador de posición.
 \item $WaitDelete(self, last)$ el comportamiento de reemplazo es $WaitDelete$.
 \end{description}


\subsubsection*{Comportamiento de waitDelete}

\begin{lstlisting}[language=sal, style=simple]
def waitDelete(last, client)[content, newFirst]
  send [content] to client
  if (newFirst = nil) then
    become emptyQueue()
  else
    become queue(newFirst, last)
end def
\end{lstlisting}

\begin{description}
 \item [Linea 2] reenvía a $client$ el valor $content$ recibido
 \item [Linea 4] Si el valor del primer nodo es nulo, el comportamiento de reemplazo es $emptyQueue$
 \item [Linea 6] El comportamiento de reemplazo es $queue$. Utiliza como primer nodo el nodo recibido en la comunicación.
\end{description}

\begin{process}

WaitDelete(self, client, last) = \\ \quad
  \begin{block}
  CommRecv.self?(ACTOR.newFirst, INT.content) \then \\ 
  CommSend.client?(INT.content, None) \then \\ \quad 
  \If newFirst == NoId \Then \\ \quad
    \begin{block}
      EmptyQueue(self)
    \end{block} \\ 
  \Then \\ \quad
    \begin{block}
    Queue(self, ACTOR.newFirst, ACTOR.last)
    \end{block}
  \end{block} 
\end{process}

\begin{description}
 \item $CommRecv.self?(ACTOR.newFirst, INT.content)$ Espera recibir un mensaje, donde el primer elemento es de tipo $ACTOR$ y lo guarda en $newFirst$, y el segundo elemento es de tipo $INT$ y lo guarda en $value$
 \item $CreateAsk?node.pid!(INT.value, ACTOR.NoId)$ crea un nuevo actor de tipo $node$, guarda en en $newLast$ el buzón. Inicializa los valores \textit{acquaiantence-list} con el entero $value$ y el buzón nulo $NoId$.
 \item $CommSend.client!(INT.content, None)$ Envía una comunicación al buzón $client$, la lista con el valor $INT.content$ y $None$. En este caso $None$ es solo un marcador de posición. 
 \item $EmptyQueue(self)$ Si el valor recibido como el nuevo primer nodo de la cola es $NoId$, el comportamiento es $EmptyQueue$. La lista vuelve al estado \textit{vacio}.
 \item $Queue(self, ACTOR.newFirst, ACTOR.last)$ El comportamiento de reemplazo es $Queue$ reemplazando el valor del primer nodo por $newFirst$.
 \end{description}
 
La \textit{cola} tiene dos tranciciones, cuando está vacia y se agrega un nodo transciona del comportamiento $emptyQueue$ al comportamiento $Queue$. Cuando tiene un único nodo y se lo remueve, transiciona del comportamiento $Queue$ a $emptyQueue$. Tambien tiene un funcionamiento habitual, es decir cuando se agregan y quitan nodos y hay mas de un nodo en la \textit{cola} previamente.


\begin{description}
 \item  
\end{description}



\subsection{Ejemplo: Un cliente-servidor de chat}


\section{Una semantica en CSP}

TODO: Definir \textbf{translateExp}

La clase \textbf{Cmnd} con elementos de tipo S está dada por:

\begin{verbatim}
S :== S_1 ; S_2 | if b then S_1 else S_2 | send [e1, .., e_i] to a | become new
E(e_1, .. ,e_i) | let a_1 = new E_1(e_1,..,e_i) and ... a_j = new
E_1(e_1,..,e_i) { S } 
\end{verbatim}

definimos la funcion \textbf{translateCmd} de la siguiente forma:

\begin{verbatim}
translateCmd (S_1 S_2) = translateCmd(S_1) -> translateCmd(S_2)
\end{verbatim}


\begin{verbatim}
translateCmd(if b then S_1 else S_2) = 
   if (translateExp(b)) then
       translateCmd(S_1) else 
       translateCmd(S_2)
\end{verbatim}

\begin{verbatim}
translateCmd(send[e_1, ..., e_i] to a) = CommSend.a.
         (translateExp(e_1), ..., 
          translateExp(e_i)) 
\end{verbatim}

\begin{verbatim}
translateCmd(become new Beh(e_1, ..., e_n)) = runningBeh(self, e_1, ..., e_n)
\end{verbatim}

newEnv es el resultado de agregar a el entorno de las variables de mailbox $a_1
= E_1.pid_1$ .. $a_n = E_n.pid_n$
\begin{verbatim}
translateCmd(let a_1 = new E_1(e_1, ..., e_j) and 
         ... and a_n = new E_N(e_1, ..., e_j) { S } = 

CreateAsk?E_1.pid_1!(translateExp(e_1), ...,translateExp(e_j)) ->
CreateAsk?E_N.pid_n!(translateExp(e_1), ...,translateExp(e_j)) ->
translateCmd(S, newEnv)
\end{verbatim}


La clase \textbf{Beha} con elementos de tipo S está dada por:

\begin{verbatim}
def behName(a_1 .. a_i)[n_1 ... n_j]
  S
end def
\end{verbatim}

Tendria como equivalente en CSP:

\begin{verbatim}

behName = ||| actorId : {|BehName|} @ Create.actorId?(a_1, ..., a_i) ->
behNameRunning(actorId, a_1, .., a_n)

behNameRunning(self, a_1, .., a_n) = CommRecv.self(n_1 ... n_j) -> translateCmd(S)

\end{verbatim}
