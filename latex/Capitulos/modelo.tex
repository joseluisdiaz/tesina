\chapter{El modelo de actores en CSP}
En este capítulo se modela el sistema de actores utilizando \CSP. Este modela los diferentes funcionalidades definidas por \SAL, Tales como crear nuevos actores, enviar mensajes, y definir un comportamiento de reemplazo. 

Se comienza por una descripción detallada de cada componete, luego se introducen ejemplos escritos en el lenguaje de programación \SAL y su equivalente en \CSP. Se presenta una función que traduce de \SAL a \CSP. Para terminar mostrando algunas particularidades sobre el modelo propuesto al utilizar la herramienta \FDR.

\section{Describiendo el sistema de actores} 
En esta sección se describe los dos componentes fundamentales para construir el modelo. Primero se verá el buzón, luego dos ecuaciones necesarias para crear la red de actores y para terminar se mostrará como es posible describir comportamientos usando \CSP. 

%Se simula la creación definiendo cada proceso con la espera de un mensaje que de inicio. Esto podría verse como la palabra reservada $new$ en varios lenguajes de programación orientados a objetos. 

\subsection{Buzón}\label{modelo:buzon}

La naturaleza de \CSP es sincrónica y los actores no lo son. Para esto se necesita desacoplar el envío de mensajes de la recepción. Se utiliza una estructura intermedia que actúa de \textit{buzón}, y dos canales que sirven para comunicarse con ella.

Un \textit{buzón} puede guardar más de una comunicación en su interior. Las comunicaciones se agregan al final, y se consumen sobre el principio. En este sentido, es una cola de tipo FIFO, \footnote{del acrónimo inglés de First In, First Out (``primero en entrar, primero en salir'')}.

La ecuación de \textit{buzón} es la siguiente:

\begin{align}\label{eq:mailbox}
\begin{split}
Mai&lbox(mailboxId, \nil) = {} \\
&CommSend?mailboxId.x \then Mailbox(mailboxId, \lseq x \rseq) \\
Mai&lbox(i, \lseq x \rseq \cat xs ) = {} \\ 
   &CommRecv!mailboxId.x \then Mailbox(mailboxId, xs) \\
   &\Extchoice \\
   &CommSend?mailboxId.y \then Mailbox(mailboxId, \lseq x \rseq \cat xs \cat \lseq y \rseq ) 
\end{split}
\end{align}
donde:
\begin{description}
 \item $Mailbox(i, \nil)$ es cuando \textit{buzón} está vacío. $Mailbox(i, \lseq x \rseq \cat xs )$ es cuando tiene al menos un mensaje. 
 \item $CommSend$ canal utilizado para comunicar desde cualquier actor hacia el buzón.
 \item $CommRecv$ canal utilizado para comunicar del buzón hacia el actor asociado.
 \item en $mailboxId.x$ y $mailboxId.y$, $mailboxId$ es la dirección del buzón, $y$ es la información que se recibe desde un actor y $x$ es la información que se envía hacia un actor.
 \end{description}
El comportamiento del proceso $Mailbox$ depende de su estado, si no tiene ningún mensaje, o si tiene al menos algún mensaje. 

\begin{itemize}
\item Si no tiene ningún mensaje, solo sincroniza mensajes por el canal $CommSend$.
\item Si tiene algunos mensajes, por los canales $CommSend$ y $CommRecv$.
\end{itemize}

Por cada actor en la red existe un \textit{buzón} con el mismo $mailboxId$ asociado. Para esto utilizamos la siguiente ecuación:
\begin{equation}\label{eq:mailbox}
Mailboxes = \Interleave_{ actor : MailboxIDS } Mailbox(actor, \nil) 
\end{equation}

donde $Mailboxes$ representa todos los buzones puestos en paralelo utilizando el operador de entrelazado. Como no existe comunicación entre buzones es que se elige este operador. $MailboxIDS$ es un conjunto de enteros, estos enteros representan un identificador único para los buzones. Tendrá que tener tantos elementos, como actores sean necesarios.

\subsection{Crear nuevos actores}\label{modelo:crear}

Dentro de las acciones que un actor efectúa está la de crear otro actor. En \CSP los actores corresponden a procesos, como todos los procesos tienen que estar definidos desde el comienzo, en \CSP no existe la posibilidad de crear dinámicamente un nuevo proceso.

Para identificar que actor se está queriendo crear, se utiliza el siguiente conjunto: 

\begin{equation}\label{eq:actorid}
  ActorID = { ACTOR_1, ACTOR_2, \ldots, ACTOR_K, MAIN }
\end{equation}

Para resolver el problema asociado a no poder instanciar nuevos procesos en \CSP, se presentan a continuación dos abstracciones.

La primera abstracción es un preámbulo a un comportamiento, le asigna a este los parámetros \textit{acquaiantence-list} y al mismo tiempo le otorga al actor su identificador único de \textit{buzón}. Utilizamos para esto un conjunto de procesos puestos en paralelo, y un canal que sincroniza con un evento especial, que da inicio al actor.
\begin{equation}\label{eq:createactor}
ks = \Interleave_{i: \{1 .. N_k\}} Create.ACTOR_k?self?<p1, p2> \then K(self, p1, p2) 
\end{equation}
donde:
\begin{itemize}
 \item $N_k$ define la cantidad de actores de tipo $K$ que se van a estar disponibles.
 \item $Create.k?self?<p1, p2>$, sincroniza en el canal $Create.ACTOR_k$, donde $ACTOR_k$ es parte del conjunto $ActorID$. Recibe el identificador de buzón $self$ como parámetro y la lista $<p1, p2>$. En este caso se supone que $K$ tiene solo dos parámetros de tipo \textit{acquaiantence-list}. 
 \item $K(self, p1, p2)$ llama al proceso parametrizado definido como $K$ con los parámetros $self$, $p1$ y $p2$. $K$ representa el comportamiento del actor
\end{itemize}

En realidad, la creación es algo ficticio, ya que tenemos una red de procesos \CSP esperando al evento $Create.ACTOR_k$ para arrancar con el comportamiento definido. 

%El conjunto definido por $ACTOR_k$ es equivalente a los elementos definidos en $ActorID$. Por esto es que decimos que no sólo define el nombre, sino que al mismo tiempo está estableciendo cuantos actores del tipo $ACTOR_k$ se va a tener.

El proceso que representa a todos los actores que van a ser iniciados en paralelo, utiliza el operador de entrelazado. Una vez sincronizado en el mensaje $Create$, se ejecuta el comportamiento que obtiene el identificador del buzón y los parámetros recibidos. 

La segunda abstracción es un proceso que vuelve asincrónica el mensaje de creación, de la creación como tal. Para esto se utiliza una estructura intermedia $create$ y un canal para comunicarse con ella. $create$ se define de la siguiente 

\begin{equation}\label{eq:create}
\begin{split}
Create&(mailboxId) = \\
&CreateAsk?actorId!mailboxId?m \then \\
&Create.actorId?mailboxId!m \then \\
&STOP
\end{split}
\end{equation}

donde:
\begin{description}
 \item $CreateAsk?actorId!mailboxId?m$ sincroniza en el canal $CreateAsk$. Recibe $actorId$, el identificador de actor a crear. Envía el identificador de buzón $MailboxID$ y recibe la lista de valores $m$.
 \item $Create.actorId?mailboxId!m$ sincroniza en el canal $Create.actorId$, vista en la ecuación \ref{eq:createactor}. Envía el identificador de buzón $MailboxID$ y la lista de valores $m$.

\end{description}
Es necesario crear tantos procesos como elementos existan en el conjunto $MailboxIDS$. Para esto se utiliza la siguiente ecuación:
\begin{equation}\label{eq:creates}
Creates = \Interleave_{mailboxId : MailboxIDS} Create(mailboxId)
\end{equation}

\subsection{Definición de comportamientos}
La idea de comportamiento fue introducida en la sección \ref{actores:beha}. Podemos pensar a un comportamiento como una función que procesa una comunicación y tiene como salida: nuevas comunicaciones, nuevos actores y el comportamiento de reemplazo para el actor que esta procesando la comunicación. A continuación se muestra como realizar estas operaciones en \CSP utilizando las construcciones anteriores.

\subsubsection*{Enviar nuevas comunicaciones}
 Para enviar la comunicación al actor con dirección de buzón $d$, y la lista de valores $<p_1, p_2, \ldots p_n>$, utilizamos la siguiente termino de \CSP:
\begin{align*}
CommSend.d!<p_1, p_2, \ldots, p_n> 
\end{align*}

Este evento sincronizará con el evento correspondiente al proceso $Mailbox$, visto en la ecuación \ref{eq:mailbox}. El cual almacena $<p_1, p_2, \ldots, p_n>$ en una lista. Mas tarde $Mailbox$ tomará este mensaje y lo enviará a otro actor. 

Como se verá en los ejemplos de la sección siguiente, todos los comportamiento de los diferentes actores comienzan con una construcción similar a $CommRecv$.

\subsubsection*{Crear nuevos actores}
Para crear un actor de tipo $actor_m$  con una lista de parametros $<p_1, p_2, \ldots p_m>$, se utiliza el siguiente termino de \CSP: 
\begin{equation*}
CreateAsk.actor_m?buzon!<p_1, p_2, \ldots, p_m> 
\end{equation*}	
donde $buzon$ es la dirección de buzón recibida y que corresponde a la dirección del actor creado.

\subsubsection*{Comportamiento de reemplazo}
Para definir un comportamiento de reemplazo $K$ con una lista de parámetros $<p_1, p_2, \ldots p_m>$, se deberá utilizar el siguiente termino: 
\begin{align*}
K(self, p_1, p_2, \ldots, p_m) 
\end{align*}	
donde $K$ es un proceso \CSP que define el comportamiento y $self$ es una variable definida por el preludio visto en la ecuación \ref{eq:createactor}.
En caso de no querer especificar comportamiento de reemplazo, se deberá usar el termino $STOP$ de \CSP para indicar que este actor finalizó.
\section{Ejemplos}

En esta sección se muestran cuatro ejemplos. Los dos primeros son los vistos en la sección \ref{sal:factorial} y \ref{sal:pila} modelados en \CSP en vez de \SAL. Los siguientes dos son nuevos, uno es la estructura de datos \textbf{cola} y el otro un ejercicio tomado del libro \textit{Programming Erlang}\cite{Cesarini:2009:EP:1717841}.

\subsection{Ejemplo: cálculo de factorial en CSP}
En esta sección se describe el funcionamiento del factorial. Es una implementación en \CSP del ejemplo antes visto en \SAL. Está compuesto por dos comportamientos $Factorial$ y $FactorialWorker$.

Continuando con la mecánica del capítulo anterior, primero se presenta el código en \CSP, luego se comentan las líneas de interés, para terminar con un pequeño detalle del funcionamiento.

El primero de los comportamientos, es el de $Factorial$ que viene dado por la siguiente forma:
\begin{process}
Factorial(self) = {} \\ \quad
  \begin{block}
  CommRecv?self.\langle mailboxClient, k \rangle \then {} \\ \quad
    \begin{block} \quad
      \begin{block} 
      ( CommSend!mailboxClient.\langle 1 \rangle \then \\
      Factorial(self) )
      \end{block} \\
     {} \lceil\ k == 0\ \rceil  \\ \quad
      \begin{block}
      ( CreateAsk.factorialWorker?pid!\langle k, mailboxClient \rangle \then \\
      CommSend!self.\langle pid, k - 1 \rangle \then \\
      Factorial(self) )
      \end{block}
    \end{block}
  \end{block}
\end{process}


\begin{description}
 \item $CommRecv?self.<mailboxClient, k>$ espera recibir una comunicación con los parámetros de tipo, el primero buzón y el segundo un entero.
 \item $\If (k == 0)$ Compara $k$ con el valor cero.
 \item $CommSend!mailboxClient.\langle 1 \rangle$ envía una comunicación al buzón $mailboxClient$ la lista con el valor $1$.
 \item $CreateAsk.factorialWorker?pid!\langle k, mailboxClient \rangle$ crea un nuevo actor de tipo $FactorialWorker$, guarda en $pid$ la dirección del buzón. Inicializa los valores \textit{acquaiantence-list} con el entero $k$ y el buzón $mailboxClient$.
 \item $CommSend!self.<pid, k - 1 >$ Se auto envía un mensaje, con el valor de buzón del actor creado en la linea anterior, y el entero $k$ decrementado en uno.
 \item $Factorial(self)$ define como siguiente comportamiento, $Factorial$ para el buzón $self$.
\end{description}

Cuando recibe un entero distinto de cero ejecuta dos acciones, crea un actor \textbf{FactorialWorker} y se envía un mensaje a si mismo para evaluar el factorial de \textbf{n - 1}. En este caso el comportamiento de reemplazo para el buzón actual no cambia. Para una descripción mas detallada revisar la sección \ref{sal:factorial}

El segundo de los comportamientos, es el de $FactorialWorker$ que viene dado de la siguiente forma:

\begin{process}
FactorialWorker(self, k, mailboxClient) = {} \\ \quad
  \begin{block}
  CommRecv.self?\langle n \rangle \then {} \\ \quad
    \begin{block}
    CommSend.mailboxClient!\langle n * k \rangle \then \\
    STOP
    \end{block}
  \end{block}
\end{process}

\begin{description}
 \item $CommRecv.self?\langle n \rangle$ Espera una comunicación que contenga un entero, y lo guarda en $n$.
 \item $CommSend.mailboxClient!\langle n * k \rangle$ envía el resultado de la multiplicación a la dirección de buzón $mailboxClient$
\end{description}

Este comportamiento es muy simple, en el momento de creación recibe dos parámetros, un entero $k$ y un dirección de un buzón. Al momento de recibir una comunicación, efectúa la multiplicación del valor recibido por $k$ y se lo envía a $mailboxClient$.

En este caso no cuenta con comportamiento de reemplazo, entonces termina con $STOP$.

Tanto para $Factorial$ y para $FactorialWorker$ faltan definir los procesos que van a dar inicio a los actores. Los cuales se encuentran definidas en la sección \ref{modelo:crear}. 

\subsection{Ejemplo: una pila}
En este ejemplo se construye una estructura de datos de tipo \textbf{pila}, la cual está compuesta de un solo comportamiento $node$ que es el que se encarga de recibir las operaciones $'push'$ y $'pop'$. En este caso se agrega al modelo $fwd$ que como veremos, está encargado de modelar el comportamiento $\textbf{become}\ buzon$.

El comportamiento de $fwd$ está definido de la siguiente forma:

\[
  fwd(a, b) = CommRecv.a?msg \then CommSend.b!msg \then fwd(a, b)
\]

El proceso anterior, reenvía todas las comunicaciones desde el buzón de $a$, al buzón de $b$.

El comportamiento de $node$ está definido de la siguiente forma:

\begin{process}
Node(self, content, link) = {} \\ \quad
\begin{block}
CommRecv.self?\langle 'push', newContent \rangle \then \\
CreateAsk.node?newNode!\langle content, link \rangle \then \\
Node(self, newContent, newNode)
\end{block} \\
\Extchoice \\ \quad
\begin{block}
CommRecv.self?\langle 'pop', client \rangle \then  \\
CommSend.client!\langle content \rangle \then  \\
fwd(self, link)
\end{block}

\end{process}

Donde:

\begin{description}
 \item $CommRecv.self?\langle 'push', newContent \rangle$ espera recibir un mensaje, donde el primer elemento de la lista es la constante $'push'$. Guarda en $newContent$ el valor del segundo elemento de la lista.
 \item $CreateAsk.node?newNode!\langle content, link \rangle$ crea un actor de un tipo $Node$ y guarda en $newNode$ el valor de la dirección del buzón. Inicializa los valores \textit{acquaiantence-list} con valor $content$ y el buzón $link$.
 \item $Node(self, newContent, newNode)$ define como comportamiento para el buzón $self$, el mismo comportamiento con los parámetros, $newContent$ y el buzón creado en la linea anterior.
 \item $CommRecv.self?\langle 'pop', client \rangle$ espera recibir un mensaje, donde el primer elemento de la lista sea la constante $'pop'$, guarda en $client$ el valor del segundo elemento de la lista.
 \item $CommSend.client!\langle content \rangle$ envía una comunicación al buzón $client$ la lista con el valor $content$.
 \item $fwd(self, link)$ se comporta como el proceso $fwd$.
\end{description}

Cuando la operación es de tipo $'pop'$, se envía el valor que contiene el nodo al buzón $client$ y se reenvían todos los mensajes a $link$, todas las futuras operaciones $'push'$ y $'pop'$ las recibe este nodo.

Cuando la operación es de tipo $'push'$, la pila crea un nuevo actor $node$. Se copia en $Node.newNode$ el nodo actual, y se reemplaza el contenido del nodo actual con el contenido recibido. Esto puede verse como el reemplazo de la cabeza de la pila.

\subsection{Ejemplo: una cola}\label{ejemplo:cola}

En este ejemplo se explora cómo construir una estructura de datos de tipo \textit{cola}, la cual se modela como si fuera una máquina de estados, dónde cada comportamiento corresponde a un estado y las comunicaciones son quienes disparan las transiciones de estos. Primero se muestra el ejemplo escrito utilizando \SAL, y luego su equivalente en \CSP.

Existen dos operaciones posibles para efectuarse en una \textit{cola} $QUEUE$ o encolar, y $DEQUEUE$ o desencolar. La primera operación agrega un nodo al final, y la segunda lo remueve del principio. 

Tanto el ejemplo en \SAL como el de \CSP tienen cuatro comportamientos:

\begin{description}
 \item [node] Guarda el contenido y una referencia al siguiente nodo en la \textit{cola}, son los eslabones de construcción de una suerte de lista enlazada.
 \item [queue] Quien se encarga de gestionar los nodos. Tiene referencia a dos nodos, el primero y el último. Para poder remover el primero, y agregar sobre el final.
 \item [emptyQueue] Este es el comportamiento es cuando la \textit{cola} no tiene ningún nodo en ella.
 \item [waitDelete] Un estado transicional, es utilizado cuando se elimina un nodo de la \textit{cola}.
\end{description}

En el resto de la sección se detallaran cada uno de los cuatro comportamientos antes enumerados, para terminar con una descripción de como estos funcionan en conjunto.

\subsubsection*{Comportamiento de node}
Este comportamiento es el que está encargado de guardar el contenido que se quisiera guardar en la \textit{cola}. Consta de dos operaciones $'delete'$ e $'point\_to'$. La primer operación envía todo su contenido a una dirección de buzón y termina su ejecución. El segundo, cambia el valor de $link$.

Código en \SAL:

\begin{lstlisting}[language=sal, style=simple]
def Node(content, link) match
  ['delete', mailbox]:
    send [content, link] to mailbox
  ['point_to', newLink]:
    become Node(content, newLink);
end def
\end{lstlisting}

Donde:

\begin{description}
 \item [Líneas 2-3] Si la operación es $'delete'$, envía su contenido a $mailbox$. Como no hay comportamiento de reemplazo, este nodo termina su ejecución en este momento.
 \item [Líneas 4-5] Si la operación es $'point\_to'$, el comportamiento de reemplazo tiene un nuevo nodo al que apunta. Esta operación básicamente cambia, el nodo que está próximo en la \textit{cola}.
\end{description}

Código en \CSP:

\begin{process}
Node(self, content, link) = \\ \quad
  \begin{block}
  CommRecv.self?\langle 'delete', mailbox \rangle \then \\
  CommSend.mailbox!(content, link) \then \\
  STOP
  \end{block} \\

  \Extchoice \\ \quad
  
  \begin{block}
  CommRecv.self?\langle 'point\_to', newLink\rangle \then \\
  Node(self, content, newLink)
  \end{block}
\end{process}

Donde: 

\begin{description}
 \item $CommRecv.self?\langle 'delete', mailbox \rangle$ espera recibir un mensaje, donde el primer elemento de la lista sea la constante $'delete'$. Guarda en $mailbox$ el valor del segundo elemento de la lista, que es una dirección de buzón.
 \item $CommSend.mailbox!\langle content, link \rangle$ Envía una comunicación al buzón $mailbox$, con la lista $content$ y $link$.
 \item $STOP$ Al no haber comportamiento de reemplazo, el actor termina su ejecución.
 \item $CommRecv.self?\langle 'point\_to', newLink \rangle$ Espera recibir un mensaje, donde el primer elemento de la lista sea la constante $'point\_to'$. Guarda en $mailbox$ el valor del segundo elemento de la lista, que es una dirección de buzón.
 \item $Node(self, content, newLink)$ Define el comportamiento de reemplazo, utiliza el parámetro $newLink$ recibido en la línea como reemplazo del anterior $link$. Es decir reemplaza al nodo que apunta.
\end{description}

\subsubsection*{Comportamiento de emptyQueue}
Este comportamiento corresponde a la \textit{cola} cuando no tiene ningún nodo. La única operación posible es $'enqueue'$, que agrega un nodo. El comportamiento de reemplazo es $Queue$.

Código en \SAL:

\begin{lstlisting}[language=sal, style=simple]
def EmptyQueue() match
  ['enqueue', value]:
    let P = new Node(value, nil) in
      become Queue(P, P)
end def
\end{lstlisting}

Donde:

\begin{description}
 \item [Línea 3] Si la operación fue $enqueue$, entonces crea un nuevo nodo con el valor recibido. Como es el primer nodo que va a tener la cola, el parámetro del siguiente nodo en la pila es $nil$.
 \item [Línea 4] El comportamiento de reemplazo para este actor es $Queue$. Como es el único nodo que tiene la \textit{cola} el primer y el último actor es el actor creado en la linea anterior.
\end{description}

Código en \CSP:

\begin{process}
EmptyQueue(self) = \\ \quad
  \begin{block}
  CommRecv.self?\langle 'enqueue', value \rangle \then \\ 
  CreateAsk.node?pid!\langle value, Null\rangle \then \\
  Queue(self, pid, pid)
  \end{block}
\end{process}

\begin{description}
 \item $CommRecv.self?\langle 'enqueue', value \rangle$ espera recibir un mensaje, donde el primer elemento de la lista sea la constante $'enqueue'$, guarda en $value$ el valor del segundo elemento.
 \item $CreateAsk.node?pid!\langle value, Null \rangle$ crea un nuevo actor de tipo $node$, guarda en en $pid$ el buzón. Inicializa los valores \textit{acquaiantence-list} con el entero $value$ y $Null$.
 \item $Queue(self, pid, pid)$ define a $Queue$ como el comportamiento de reemplazo, para el buzón $self$. Le pasa como parámetro la dirección del buzón del actor antes creado, se repite por que tanto el primer como el ultimo nodo es el mismo cuando la \textit{cola} tiene un solo nodo.
\end{description}

\subsubsection*{Comportamiento de queue}
Este comportamiento es cuando la cola tiene al menos un nodo. Tiene dos operaciones $'enqueue'$ y $'dequeue'$. La primera agrega un nodo y la segunda lo remueve. Al remover un nodo, es necesario obtener la referencia al nuevo primer nodo, es decir, al que apuntaba el nodo que esta por ser removido. Para esto se utiliza el comportamiento $waitDelete$.

Código en \SAL:

\begin{lstlisting}[language=sal, style=simple]
def Queue(first, last) match 
  ['enqueue', value]: 
    let newLast = new node(value, nil) in
      send [insert, newLast] to last
      become queue(first, newLast)
  ['dequeue', client]: 
    send [delete, self] to first
    become waitDelete(last, client)
end def
\end{lstlisting}

Donde:

\begin{description}
 \item [Línea 1] $first$ y $last$ son respectivamente, el primer y último nodo de la \textit{cola}.
 \item [Línea 3] Si la operación fue $enqueue$, entonces crea un nuevo nodo con el valor recibido. Como este nodo será el último, no apunta a nadie.
 \item [Línea 4] Le envía un mensaje a $last$ para que intercambie el valor al que apunta, por el valor del nodo recién creado.
 \item [Línea 5] El comportamiento de reemplazo es el mismo, lo único que cambia es el valor del buzón del último nodo ($last$) por el nodo recién creado.
 \item [Línea 7] Borra el primer nodo en la lista.
 \item [Línea 8] El nuevo comportamiento es un estado intermedio llamado $waitDelete$.
\end{description}

Código en \CSP:

\begin{process}
Queue(self, first, last) = \\ \quad
  \begin{block}
  CommRecv.self?\langle 'enqueue', value \rangle \then \\
  CreateAsk.node?newLast!\langle value, Null \rangle \then \\
  CommSend.last!\langle 'insert', newLast \rangle \then \\
  Queue(self, first, newLast)
  \end{block} \\

  \Extchoice \\ \quad
  
  \begin{block}
  CommRecv.self?\langle 'dequeue', client \rangle \then \\
  CommSend.first!\langle 'delete', self \rangle \then \\
  WaitDelete(self, client, last)
  \end{block} 
\end{process}

Donde:

\begin{description}
 \item $CommRecv.self? \langle 'enqueue', value \rangle$ espera recibir un mensaje, donde el primer elemento de la lista sea la constante $'enqueue'$. Guarda en $value$ el valor del segundo elemento de la lista.
 \item $CreateAsk?node.pid!\langle value, Null \rangle$ crea un nuevo actor de tipo $node$, guarda en en $newLast$ el buzón. Inicializa los valores \textit{acquaiantence-list} con el valor $value$ y $Null$.
 \item $CommSend.first!\langle 'insert', newLast \rangle$ Envía una comunicación al buzón $first$, con la lista $'insert'$ y el actor creado en la linea anterior. 
 \item $Queue(self, first, newLast)$ Define a $Queue$ como el comportamiento de reemplazo, para el buzón $self$. Pasa como parámetro la dirección del buzón del actor antes creado como reemplazo del último nodo de la pila.
 \item $CommRecv.self?\langle 'dequeue', client \rangle$ espera recibir un mensaje, donde el primer elemento de la lista sea la constante $'dequeue'$, guarda en value el valor del segundo elemento de la lista,.
 \item $CommSend.first!\langle 'delete', self \rangle$ Envía una comunicación al buzón $first$, con la lista $'delete'$ y la dirección del buzón de la actor \textit{cola}. 
 \item $WaitDelete(self, client, last)$ el comportamiento de reemplazo es $WaitDelete$. Este comportamiento será descripto a continuación.
 \end{description}

\subsubsection*{Comportamiento de waitDelete}
Este comportamiento es un estado intermedio. Está a la espera de los datos del nodo que está siendo removido. Una vez que llega el contenido, este se envía a quien originalmente pidió remover el nodo. Si el nodo que se borró era el último, el nodo al que apuntaba será $nil$, entonces se tiene que comportar como si la cola estuviera vacía. En caso contrario se comporta como la cola con al menos un elemento.

Código en \SAL:

\begin{lstlisting}[language=sal, style=simple]
def waitDelete(last, client)[content, newFirst]
  send [content] to client
  if (newFirst = nil) then
    become emptyQueue()
  else
    become queue(newFirst, last)
end def
\end{lstlisting}

Donde: 

\begin{description}
 \item [Línea 2] Reenvía a $client$ el valor $content$ recibido
 \item [Línea 4] Si el valor del primer nodo es nulo, el comportamiento de reemplazo es $emptyQueue$
 \item [Línea 6] El comportamiento de reemplazo es $queue$. Utiliza como primer nodo el nodo recibido en la comunicación.
\end{description}

Código en \CSP:

\begin{process}
WaitDelete(self, client, last) = \\ \quad
  \begin{block}
  CommRecv.self?\langle newFirst, content \rangle \then \\ 
  CommSend.client?\langle content \rangle \then \\ 
  \If newFirst == Null \Then \\ \quad
    \begin{block}
      EmptyQueue(self)
    \end{block} \\ 
  \Then \\ \quad
    \begin{block}
    Queue(self, newFirst, last)
    \end{block}
  \end{block} 
\end{process}

Donde:

\begin{description}
 \item $CommRecv.self?\langle newFirst, content \rangle$ Espera recibir un mensaje, donde el primer elemento es una dirección de buzón. Lo guarda en $newFirst$. El segundo elemento lo guarda en $content$
 \item $CommSend.client!\langle content \rangle$ Envía una comunicación al buzón $client$, la lista con el valor $content$. 
 \item $EmptyQueue(self)$ Si el valor recibido como el nuevo primer nodo de la cola es $Null$, el comportamiento de reemplazo es $EmptyQueue$. La lista vuelve al estado vacío.
 \item $Queue(self, newFirst, last)$ El comportamiento de reemplazo es $Queue$. Cambia el valor del primer nodo por $newFirst$.
 \end{description}
 
La \textit{cola} tiene dos transiciones, cuando está vacía y se agrega un nodo cambia del comportamiento $EmptyQueue$ al comportamiento $Queue$. Cuando tiene un único nodo y se lo remueve, cambia del comportamiento $Queue$ a $EmptyQueue$. También tiene un funcionamiento habitual, es decir cuando se agregan y quitan nodos y hay más de un nodo en la \textit{cola}.

Supongamos que se quiere insertar un nodo ($'enqueue'$), con el valor $42$ en una \textit{cola} con ningún nodo en ella. La interacción entre los actores tendría la siguiente forma:

\begin{itemize}
 \item Recibe una comunicación con la lista $'enqueue'$ y $42$.
 \item El buzón del actor que tiene el comportamiento $EmptyQueue$:
 \item Crea un nuevo nodo y guarda la dirección del buzón en $P$.
 \item Como es el primer nodo en la \textit{cola}, el siguiente nodo es el nodo vacío.
 \item El comportamiento de reemplazo es $Queue$, como es el único nodo en la lista, el primer y el último nodo coinciden y es el nodo recién creado.
\end{itemize}

Supongamos que queremos insertar un nodo ($'enqueue'$), con el valor $42$ en una \textit{cola} con al menos un nodo en ella, la interacción entre los actores tendría la siguiente forma:

\begin{itemize}
 \item El buzón del actor que tiene el comportamiento $Queue$:
 \subitem Recibe una comunicación con la lista $'enqueue'$ y $42$.
 \subitem Crea un nuevo nodo, y guarda la dirección del buzón en $newLast$.
 \subitem Reenvía un mensaje al último nodo en la \textit{cola} ($last$) para que cambie al nodo que apunta.
 \subitem Cambia cual es el último nodo en $Queue$, ahora es $newLast$.
 \item El buzón del nodo que hasta ese momento era el último ($last$):
 \subitem Recibe una comunicación con la lista $'insert'$ y $mailbox$.
 \subitem En el comportamiento de reemplazo, cambia el valor de $link$ por $mailbox$. Esto hace que apunte a un nuevo nodo, el que fue insertado.
\end{itemize}

Supongamos que queremos remover el primer nodo ($'dequeue'$), y enviarle el contenido a un actor $client$. La interacción entre los actores tendría la siguiente forma:

\begin{itemize}
 \item El buzón del actor que tiene el comportamiento $Queue$ recibe una comunicación con la lista $'dequeue'$ y una dirección de buzón ($client$) para enviar el contenido del primer nodo.
 \subitem Le envía al actor que está primero en la cola ($first$) un mensaje para que se borre, con una dirección de buzón a quien enviarle su contenido.
 \subitem Cambia en un comportamiento intermedio, el cual esperará el contenido del nodo que será borrado.
 \item El buzón del nodo que hasta ese momento era el primero ($first$):
 \subitem Recibe una comunicación con la lista $delete$ y $mailbox$.
 \subitem Envía su contenido, tanto $link$ que es a la dirección de buzón al que apunta (el siguiente nodo en la \textit{cola}), como el contenido que guarda al buzón $mailbox$. Como no tiene comportamiento de reemplazo, este actor termina su ejecución en este momento.
 \item El buzón del actor que tiene el comportamiento $WaitDelete$ recibe una comunicación con la lista $content$ y una dirección de buzón. Esta dirección ea a la que el primer nodo apunta, es decir el siguiente nodo.
 \subitem Se envía el contenido a quien originalmente lo pidió ($client$).
 \subitem Si la dirección a la que apuntaba era $Null$, esto quiere decir que era el último nodo en la lista. Se comporta como $emptyQueue$.
 \subitem En caso contrario, cambia al comportamiento $Queue$, con un nuevo nodo como el primer nodo en la \textit{cola}.
\end{itemize}


\subsection{Ejemplo: un anillo de actores}
Este ejemplo propuesto como ejercicio en el libro \textit{Programming Erlang}\cite{Cesarini:2009:EP:1717841}\footnote{Página 115, Ejercicio 4-2: The Process Ring}. El ejercicio propone crear una red de $n$ procesos como muestra la figura \ref{fig:anillo}. Una vez terminada de establecerse, el primero de estos nodos envía un mensaje al siguiente nodo en su red.  Una vez enviados $m$ mensajes dentro del anillo, los nodos deberían terminar su ejecución.

\begin{figure}[H]
\centering
\begin{tikzpicture}
\tikzstyle{nodo} = [draw, circle, minimum size=1.5em]

\node[nodo] (A1) at (1,0) {};
\node[nodo] (A2) at (2.5,0) {};
\node[nodo] (A3) at (4,0) {};
\node[nodo] (A4) at (5.5,0) {};
\node[nodo] (A5) at (7,0) {};

\draw[->] (A1) -- (A2);
\draw[->] (A2) -- (A3);
\draw[->] (A3) -- (A4);
\draw[->] (A4) -- (A5);

\draw[->] (A5) edge [bend left=20] (A1);
\end{tikzpicture}
\caption{Anillo de procesos con $n=5$}
\label{fig:anillo}
\end{figure}

Para resolver este problema, se plantean tres comportamientos:

\begin{description}
 \item [Node] modela cada nodo del anillo.
 \item [Ring] espera un mensaje con una cantidad de nodos a crear, y una cantidad de mensajes a enviar.
 \item [BuildingRing] cumple la función de estructura de control, crea el anillo de nodos.
\end{description}

\subsubsection*{Comportamiento de Node}

\textbf{Node} reacciona entre dos comunicaciones diferentes: $'point\_to'$ y $'msg'$. En el caso de $'point\_to'$, cuando lo procesa, cambia al nodo que apunta. Cuando procesa un mensaje de tipo $['msg']$, siempre reenvía al siguiente nodo en la lista la comunicación $['msg']$. Si el valor del contador $m$ es mayor que cero, se disminuye el contador en uno y sigue con la ejecución. Si es cero, termina la ejecución en ese momento.

Código en \SAL para \textbf{Node}:

\begin{lstlisting}[language=sal, style=simple]
def Node(m, next) match
  case ['point_to', newNext]:
    become Node(m, newNext)
  case ['msg']:
    if ( m = 0 ) then
      send ['msg'] to next
    else
      send ['msg'] to next
      become Node(m - 1, next)
    end if
end def
\end{lstlisting}

Código en \CSP:

\begin{process}
Node(self, m, next) = \\ \quad
  \begin{block}
  CommRecv.self?\langle 'point\_to', newNext \rangle \then \\
  Node(self, m, newNext)
  \end{block} \\

  \Extchoice \\ \quad
  
  \begin{block}
  CommRecv.self?\langle 'msg' \rangle \then {} \\ \quad
    \begin{block}
    \If (m == 0) \Then {} \\ \quad
      \begin{block} 
      CommSend!next.\langle 'msg' \rangle \then \\
      STOP
      \end{block} \\
    \Else {} \\ \quad
      \begin{block}
      CommSend!next.\langle 'msg' \rangle \then \\
      Node(self, m - 1, next) 
      \end{block}
    \end{block}
  \end{block} 
\end{process}

% Donde:
% 
% \begin{description}
%  \item [Linea 2-3] Si responde a un mensaje de tipo $'point_to'$, el comportamiento de reemplazo es \textbf{Node} pero cambiando el parametro $next$ por $newNext$.
%  \item [Linea 4-5] Si responde a un mensaje de tipo $'msg'$, y su contador $m$ es mayor que cero, envia un mensaje al proximo actor el anillo ($next$). Su comportamiento de reemplazo es \textbf{Node} pero decrementando en uno el contador $m$.
%  \item [Linea 7] Si responde a un mensaje de tipo $'msg'$, y su contador $m$ era cero, envia un mensaje al proximo actor en el anillo ($next$). Como no define comportamiento de reemplazo, termina su ejecución en es momento.
% \end{description}

\subsubsection*{Comportamiento de Ring}

Cuando \textbf{Ring} recibe una comunicación con una lista que tiene un par de enteros, el primero de los enteros es la cantidad de nodos a crear, y el segundo es la cantidad de comunicaciones a mandar. Crea el primer nodo que va a tener el anillo y el actor que va a estar encargado de crear el resto del anillo. Le envía un mensaje a $builder$ con el número de nodos que tiene que crear. Como el primero fue inicialiado este es decrementado en uno.

Código en \SAL:

\begin{lstlisting}[language=sal, style=simple]
def Ring()[n, m]
  let first = new Node(m, nil)
      builder = new BuildingRing(first, first) 
  in
    send [n - 1, m] to builder
    become Ring() 
end def
\end{lstlisting}

Código en \CSP:

\begin{process}
Ring(self) = \\ \quad
  \begin{block}
  CommRecv.self?\langle n, m \rangle \then \\
  CreateAsk.node?first!\langle m, Null \rangle \then \\
  CreateAsk.buildingRing?builder!\langle first, first \rangle \then \\
  CommSend.builder!\langle n - 1, m\rangle \then \\
  Ring(self)
  \end{block}
\end{process}

\subsubsection*{Comportamiento de BuildingRing}

Esta es una estructura de control, siempre que procese una comunicación con $n$ mayor a uno, crea un nuevo nodo. Le envía al nodo que creó en la iteración anterior un mensaje para que apunte al nuevo nodo creado. Se auto envía un mensaje decrementando en uno el contador de nodos a crear. El comportamiento de reemplazo cambia el nodo $lastCreated$.

Si el contador $n$ era cero, le envía un mensaje al nodo creado en la iteración anterior para que apunte al primer nodo creado ($first$). De esta manera cierra el anillo. Le envía una comunicación al primer nodo, que da inicio al envío de mensajes. 

Código en \SAL:

\begin{lstlisting}[language=sal, style=simple]
def BuildingRing(m, first, lastCreated)[n, m]
  if (n == 0) then
    send ['poins_to', first] to lastCreated,
    send ['msg'] to first
  else
    let newNode = new Node(m, null) in
      send ['point_to', newNode] to lastCreated
      send [ n - 1, m ] to self
      become BuildingRing(first, newNode)
  end if
end def
\end{lstlisting}

Código en \CSP:

\begin{process}
BuildingRing(self, first, lastCreated) = \\ \quad
  \begin{block}
  CommRecv.self?\langle n, m \rangle \then \\ \quad
  \begin{block} 
  \If (n == 0) \Then {} \\ \quad
    \begin{block}
    CommSend!lastCreated.\langle 'point\_to', first \rangle \then \\
    CommSend!first.\langle 'msg' \rangle \then \\
    STOP
    \end{block} \\
  \Else {} \\ \quad
    \begin{block} 
    CreateAsk.node?newNode!\langle m, Null \rangle \then \\
    CommSend!lastCreated.\langle 'point\_to', newNode \rangle \then \\
    CommSend!self.\langle n - 1, m \rangle \then \\
    BuildingRing(self, first, newNode) 
    \end{block} \\
  \end{block} 
\end{block}
\end{process}

\section{La semántica en CSP}

En esta sección se describe cómo traducir las expresiones, los comandos y los comportamientos desde \SAL a \CSP. Para esto se utiliza como punto de partida la gramática definida en la sección \ref{actores:sal}. Se utilizará como mecanismo de traducción unas funciones que estan definidas de manera inductiva.

Se utiliza en la descripción de las funciones de traducción la notación $x \equiv H$ cuando fuese necesario especificar que $x$ tiene la forma gramatical $H$.

\subsubsection*{Expresiones}
En la sección \ref{actores:exp} se definió la gramática para las expresiones. Para traducir estas expresiones se utiliza la función, $exp_{tr}$, definida de la siguiente forma:
\newcommand{\func}[1]{\lbag #1 \rbag}


\begin{equation*}
  exp_{tr} \func{exp} =
  \setlength{\arraycolsep}{0pt}
  \renewcommand{\arraystretch}{1.2}
  \left\{\begin{array}{l @{\quad} l}
        iexp_{tr}\func{exp}     & \text{si $exp \equiv iexp$} \\
        bexp_{tr}\func{exp}     & \text{si $exp \equiv bexp$} \\
        sexp_{tr}\func{exp}     & \text{si $exp \equiv sexp$} \\
        idexp_{tr}\func{exp}    & \text{si $exp \equiv id$} \\
  \end{array}\right.
\end{equation*}

La función para las expresiones de enteros, $iexp_{tr}$, viene dada de la siguiente forma:

\begin{equation*}
\begin{array}{l c l}
iexp_{tr}\func{iexp_1 + iexp_2} &=& iexp_{tr}\func{iexp_1} + iexp_{tr}\func{iexp_2} \\
iexp_{tr}\func{iexp_1 - iexp_2} &=& iexp_{tr}\func{iexp_1} - iexp_{tr}\func{iexp_2} \\
iexp_{tr}\func{iexp_1 * iexp_2} &=& iexp_{tr}\func{iexp_1} * iexp_{tr}\func{iexp_2} \\ 
iexp_{tr}\func{iexp_1 / iexp_2} &=& iexp_{tr}\func{iexp_1} / iexp_{tr}\func{iexp_2} \\
iexp_{tr}\lbag - iexp \rbag &=& - iexp_{tr}\lbag iexp \rbag \\
iexp_{tr}\lbag id \rbag &=& id
\end{array}
\end{equation*}

La función para traducir las expresiones booleanas, $bexp_{tr}$, es finalmente:
\begin{equation*}
\begin{array}{l c l}
bexp_{tr}\func{bexp_1 \textbf{ or } bexp_2}    &=& bexp_{tr}\func{iexp_1} \vee bexp_{tr}\func{iexp_2} \\
bexp_{tr}\func{bexp_1 \textbf{ and } bexp_2}   &=& bexp_{tr}\func{iexp_1} \wedge bexp_{tr}\func{iexp_2} \\
bexp_{tr}\func{\textbf{not } bexp }            &=& \neg bexp_{tr}\func{bexp} \\ 
bexp_{tr}\func{ exp_1 == iexp_2}               &=& exp_{tr}\func{exp_1} == exp_{tr}\func{exp_2} \\
bexp_{tr}\func{id} 							   &=& id
\end{array}
\end{equation*}

Tanto $sexp_{tr}$ como $idexp_{tr}$ no tienen una traducción asociada, podrían definirse como la función identidad.

\subsubsection*{Comportamientos}
En la sección \ref{actores:beha} se definió la gramática para los comportamientos. Para traducir estas expresiones se utilizan las funciones $beha_{tr}$ y $body_{tr}$.

La función $beha_{tr}$ viene dada por la forma:
\begin{multline*}
beha_{tr}\func{\ \textbf{def } BehName(p_1, p_2,\ldots, p_n)\ body \textbf{ end def}\ } = \\
BehName(self, p_1, p_2,\ldots, p_n) = body_{tr}\func{body} 
\end{multline*}
La función $body_{tr}$ viene dada por la forma:
\begin{multline*}
body_{tr}\func{\ [ p_1, p_2,\ldots, p_n]\ command\ } = \\
 CommRecv.self?\langle p_1, p_2,\ldots, p_n \rangle \then cmd_{tr}\func{command}
\end{multline*}
\begin{multline*}
body_{tr}\func{\ \textbf{ case } [p_{11}, p_{12},\ldots, p_{1n}]: command_1 \ldots \textbf{ case } [p_{n1}, p_{n2},\ldots, p_{nk}]: command_n\ } = \\
CommRecv.self?\langle p_{11}, p_{12},\ldots, p_{1n} \rangle \then cmd_{tr}\func{command_1} \Extchoice \ldots \Extchoice \\
CommRecv.self?\langle p_{n1}, p_{n2},\ldots, p_{nk} \rangle \then cmd_{tr}\func{command_n} 
\end{multline*}

\subsubsection*{Comandos}

En la sección \ref{actores:cmd} se definió la gramática para los comandos. Para traducir los comandos se utiliza la función $cmd_{tr}$, que se define de la siguiente forma:
\begin{multline*}
cmd_{tr}\func{\ \textbf{send } exp_1, exp_2, \ldots\ , exp_n \textbf{to } mexp\ } = \\
CommSend.mexp. \langle exp_{tr}\func{exp_1}, exp_{tr}\func{exp_2}, \ldots, exp_{tr}\func{exp_m} \rangle
\end{multline*}
\begin{multline*}
cmd_{tr} \func{\ \textbf{become}\ B(exp_1, exp_2,\ \ldots, exp_n)\ } = \\
B(exp_{tr}\func{exp_1}, exp_{tr}\func{exp_2}, \ldots, exp_{tr}\func{exp_n} \rangle
\end{multline*}
\begin{multline*}
cmd_{tr}\func{command_1 \textbf{;} command_2} = cmd_{tr}\func{command_1} \then cmd_{tr}\func{command_2}
\end{multline*}
\begin{multline*}
cmd_{tr} \func{\ \textbf{if } bexp \textbf{ then } command_1 \textbf{ else } command_2 \textbf{ end if }\ } = \\
 cmd_{tr}\func{command_1}\ \lceil bexp_{tr}\func{bexp} \rceil\ cmd_{tr}\func{command_2}
\end{multline*}
\begin{multline*}
cmd_{tr}\func{\ \textbf{let}\ id_1 = \textbf{new} B_1(exp_{11}, exp_{12},\ \ldots, exp_{1m}), \ldots, \\
id_n = \textbf{ new }B_n(exp_{n1}, exp_{n2},\ldots, exp_{nk}) \textbf{ in }command\ } = \\
CreateAsk.b_1?id_1! \langle exp_{tr}\func{exp_{11}}, exp_{tr}\func{exp_{12}},\ \ldots, exp_{tr}\func{exp_{1m}} \rangle \then \ldots \then \\
CreateAsk.b_N?id_n! \langle exp_{tr}\func{exp_{n1}}, exp_{tr}\func{exp_{n2}},\ \ldots, exp_{tr}\func{exp_{nk}} \rangle \then  \\ 
cmd_{tr}\func{command}
\end{multline*}

\subsubsection*{Pasos finales}

El sistema final consiste de todos los componentes del sistema de actores en paralelo. Los componentes a poner en paralelo son: los buzones vistos en la sección \ref{modelo:buzon}, los procesos que separan la intención de crear de la creación propiamente dicha vistos en la sección \ref{modelo:crear} y los preámbulos vistos en la misma sección.

La comunicación que va desde estos preámbulos hacia los buzones es una de las comunicaciones de interés. Los eventos en este caso son todos los generados por los buzones. Es decir el conjunto generado por $CommSend.i.j$ donde $i$ son todos los posibles actores y $j$ son los mensajes a enviar. A estos eventos se le debe unir el conjunto generado por $CommRecv.i.j$ donde $i$ son todos los posibles actores y $j$ son los mensajes a enviar. Este es el conjunto de todos los eventos posibles de los buzones. Este conjunto se denomina: $Comm$.

Otra forma de comunicación a tener en cuenta es desde estos preámbulos hacia los procesos que separan la intención de crear de la creación. Es decir el conjunto generado por $CreateAsk.i.j$ donde $i$ son todos los posibles actores y $j$ son todos los posibles valores de \textit{acquaiantence-list}. A estos eventos se le debe unir el conjunto generado por $Create.i.j$ donde $i$ son todos los posibles actores y $j$ son todos los posibles valores de \textit{acquaiantence-list}. Este conjunto se denomina $Init$.

Ahora se supone que tenemos dos redes concurrentes de actores $ks$ y $js$, definidos de la siguiente manera:

\begin{align*}
ks = \Interleave_{ i : \{ 0 .. N_k \} } & Create.k?self?<p1, p2> \then K(self, p1, p2)  \\ 
js = \Interleave_{ i : \{ 0 .. N_j \} } & Create.j?self?<p1, p2> \then J(self, p1, p2) 
\end{align*}

donde $J$ y $K$ son dos definiciones de comportamiento. Para integrar todo el sistema de actores se escribe la siguiente ecuación:
\begin{align*}
SYSTEM =  (ks \Interleave js) \Parallel\limits_{Comm \cup Init} (Mailboxes \Interleave Creates)
\end{align*}
donde $Mailboxes$ está definido en la ecuación \ref{eq:mailbox} y $Creates$ en la ecuación \ref{eq:creates} . Entre $ks$ y $js$ nunca existe ningún tipo de comunicación, por eso se usa el operador de entrelazado. Lo mismo ocurre con $Mailboxes$ y $Creates$.

\section{Corriendo los modelos en FDR}

Esta sección muestra algunas modificaciones necesarias que fueron hechas al modelo para poderlo correr utilizando \FDR. \FDR es un verificador de refinamiento para \CSP. Permite definir procesos de \CSP utilizando el lenguaje \CSPm. Se pueden verificar varias afirmaciones sobre estos procesos. A continuación se cuentan algunas de estas características.

La herramienta cuenta de la palabra reservada \textit{probe}, está sirve para explorar manualmente las transiciones de un proceso como si fuera un árbol, es muy útil para al depurar una definición de proceso. Esto fue particularmente útil al explorar la creación del modelo antes propuesto. Se mostrará un caso donde se puede ver el gráfico de todas las ejecuciones de uno de los ejemplos. 
 
También es posible verificar refinamiento utilizando el modelo de trazas o el modelo de fallas y divergencias. Se verá un ejemplo de cómo es posible verificar este tipo de afirmaciones.

Estas son algunas de las posibles pruebas que se pueden hacer utilizando la herramienta. Este conjunto de pruebas no pretende comprender un uso exhaustivo de la herramienta, para mayor información sobre la herramienta se puede consultar su manual\cite{fdrmanual}.

\subsection{Restricciones sobre el modelo}

Es necesario imponer restricciones al utilizar \FDR. Estas restricciones están relacionas a cómo la herramienta explora los estados posibles del modelo. Por ejemplo, si se utiliza el rango completo de enteros intentará revisar cada uno de estos enteros, haciendo cada exploración exponencial en cada estado que se visite. En el resto de esta sección se exploran estas restricciones. Las modificaciones que incluyen estas restricciones pueden verse en los ejemplos en el apéndice \ref{codigo}.

\subsubsection*{Enteros pequeños}

Para evitar la explosión de estados que causa utilizar el rango de enteros de \textit{64-bits}, se genera una una representación propia para reducirla. Para esto se utiliza un tipo algebraico que representa estos enteros:

\begin{align*}
datatype\ SmallInt =&\ SI.\{0 \ldots MAX\_INT\} | Overflow \\
\end{align*}
donde, $MAX\_INT$ es el entero más grande a representar. 

Aparte de esta representación de los enteros, se construyeron las operaciones básicas sobre ellos:

\begin{align*}
add(SI.a, SI.b)\ =&\ let\ sum\ = a + b \\
&within\ if\ sum <= MAX\_INT\ then\ SI.sum\ else\ Overflow  \\
%
sub(SI.a, SI.b) =&\ let\ sub\ =\ a - b \\
& within\ if\ sub >= 0\ then\ SI.sub\ else\ Overflow \\
%
mult(SI.a, SI.b) =&\ let\ mult\ = a * b \\
& within\ if\ mult <= MAX\_INT\ then\ SI.mult\ else\ Overflow \\
eq(SI.a, SI.b)\ =&\ a == b \\
eq(\_, \_)\ =&\ false
\end{align*}
donde $add$ es la suma, $sub$ la resta, $mult$ la multiplicación y $eq$ la igualdad. Si alguna operación excede el entero máximo el resultado de esta es $Overflow$.

\subsubsection*{Listas de parámetros y valores}
En en modelo se utilizan listas para representar tanto los parámetros de \textit{acquaiantence-list} y los de \textit{communication-list} dado que las listas son potencialmente infinitas, para evitar que la herramienta entre en un ciclo infinito, se limita el tamaño de las listas. Con este fin se utilizan tuplas de tamaño fijo. Para esto es necesario conocer el tamaño máximo del mensaje que se va a enviar; esta es una limitación con respecto al modelo presentado.

%La expresividad de los mensajes es grande. Un actor podría recibir un mensaje del tipo $['transferir', buz\acute{o}n_1, buz\acute{o}n_2]$, donde el primer buzón representa la caja de ahorro origen y el segundo la de destino. El siguiente mensaje que procese el mismo actor podría ser $['depositar', monto, buz\acute{o}n]$ donde monto es un entero con el monto a depositar y el buzón representa la caja de ahorro a la cual depositar. 

Para poder tener cierta flexibilidad en el momento de enviar mensajes, se crea una unión de tipos llamada $VALUE$. Este tipo codifica todos los posibles valores que son posible utilizar en el modelo: buzones, enteros, booleanos y cadenas. 

\[
  datatype\ VALUE = ACTOR.ActorID | INT.SmallInt | BOOL.Bool | ATOM.Atoms | None
\]

Como las tuplas se definen de tamaño fijo, es necesario agregar elemento que permite marcar que un elemento de la lista no se usa. Por ejemplo si las listas son de tamaño tres, no necesariamente todos los mensajes que intercambien los actores serán de esta longitud. Por caso podría existir un mensaje que sea una lista de tamaño dos ($[1, client]$). La tupla de tamaño tres sería $(1, None, None)$. 

Ya qué las cadenas son inmutables, estas son representadas utilizando un tipo enumeración, donde cada elemento de este nuevo tipo de datos es una cadena. La definición viene dada de la siguiente forma:
\[
  datatype\ Atoms = CADENA_1 | CADENA_2 | \ldots | CADENA_n
\]

donde $Atoms$ representa el conjunto de cadenas en uso.

Para simplificar como se especifica la cantidad de actores que se necesitan se extiende la definición \ref{eq:actorid}. Al conjunto de nombre de actores se agrega el conjunto de enteros que representa la cantidad, por ejemplo:

\[
  datatype ActorID = j.{1,2} | k.{1,2,3} | main.{1}
\]
donde $ActorID$ representa dos actor $j$, tres actores $k$ y un actor $main$

\subsubsection*{Cota en el buzón}

Se puede modelar un buzón que no tenga una cota superior, pero se tendría nuevamente problemas de explosión de estados ya que \FDR intentaría explorar todas las combinaciones posibles de buzón. Este caso es similar al de la lista en la comunicación. 

La ecuación de \textit{buzón}, con cota, es la siguiente:

\begin{process}

\begin{block}
MAILBOX\_SIZE = 4
\end{block} \\

\begin{block}
Mailbox(i, \nil) = {} \\ \quad
CommSend?i.x \then Mailbox(i, \lseq x \rseq) 
\end{block} \\

\begin{block}
Mailbox(i, msgs) = {} \\ \quad
  \begin{block} 
  \If (length(msgs) < MAILBOX\_SIZE - 1) \Then {} \\ \quad
    \begin{block} 
      MailboxWithSpace(i, msgs)
    \end{block} \\
  \Else {} \\ \quad
    \begin{block}
      MailboxFull(i, msgs)
    \end{block}
  \end{block} 
\end{block} \\

\begin{block}
MailboxWithSpace(i, \lseq x \rseq \cat xs ) = {} \\ \quad 
  \begin{block}
    CommRecv!i.x \then Mailbox(i, xs) \\
    \Extchoice \\
    CommSend?i.y \then Mailbox(i, \lseq x \rseq \cat xs \cat \lseq y \rseq ) 
  \end{block}
\end{block} \\

\begin{block}
MailboxFull(i, \lseq x \rseq \cat xs ) = {} \\ \quad 
  \begin{block}
    CommRecv!i.x \then Mailbox(i, xs) \\
  \end{block}
\end{block} \\
\end{process}

La ecuación anterior le agrega a la ecuación \ref{eq:mailbox}, un límite definido por $MAILBOX\_SIZE$. El comportamiento del proceso buzón depende de su estado de la siguiente forma:

\begin{itemize}
\item Si no tiene ningún mensaje, solo sincroniza mensajes por el canal $CommSend$.
\item Si tiene algunos mensajes, por los canales $CommSend$ y $CommRecv$.
\item Si llegó a su capacidad máxima $MAILBOX\_SIZE$ lo hace solo por el canal $CommRecv$.
\end{itemize}

\subsection{Algunos resultados}

A continuación se muestran dos resultados obtenidos utilizando el modelo propuesto en \CSPm. Uno explora el árbol de procesos y el otro verifica una afirmación utilizando el modelo de trazas.

\subsubsection*{Árbol de interacciones}

Utilizando la función \textit{probe} de la herramienta \FDR, se puede ver permite ver árbol de interacciones de los distintos procesos. En el caso de este modelo, permite ver cómo las diferentes interacciones de los actores.

En el proceso de desacoplar los componentes vistos en las secciones \ref{modelo:buzon} y \ref{modelo:crear}, fue necesario analizar la interacción que tienen los diferentes procesos para entender que efectivamente funcionaba de la forma esperada. Se puede ver en el ejemplo del apéndice \ref{codigo:suma}, una versión extendida para funcionar en \FDR del ejemplo de la ecuación \ref{eq:smallactor}. Este ejemplo muestra como utilizando como es posible desacoplar utilizando dos eventos, uno para la intensión de crear y otro para iniciar el actor, se puede desacoplar el inicio del proceso suma, y mejorar sustancialmente la composición en paralelo. 

Esto es muy util, ya que cada proceso que intente iniciar otro debería tener como evento de interés este evento de inicio. Al ir agregando procesos, el cálculo de que eventos de interés deberían utilizarse al ponerse en paralelo se dificulta. 

En el ejemplo, \verb=SYSTEM2=, utiliza un proceso intermedio como fue visto en la sección \ref{modelo:crear}. Se puede ver en la figura \ref{modelo:suma:system1} el árbol de procesos capturado utilizando \verb=:probe SYSTEM1=. Este sistema pone en paralelo \verb-CLIENTE- y \verb-SUMA- usando paralelismo alfabetizado. Se puede ver en la figura \ref{modelo:suma:system2} el árbol de procesos capturado utilizando \verb=:probe SYSTEM2=. Este sistema pone en paralelo \verb-CLIENTE2- y \verb-SUMA- usando entrelazado, y un proceso auxiliar \verb-INICIA-. Este ultimo proceso reduce a cero los eventos de interés entre \verb-CLIENTE2- y \verb-SUMA-.

\begin{figure}[H]
\begin{center}
\includegraphics[width=15 cm]{img/sumasystem1.png}
\caption{Árbol de interacciones de SYSTEM1 del apéndice \ref{codigo:suma}}
\label{modelo:suma:system1}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[width=15 cm]{img/sumasystem2.png}
\caption{Árbol de interacciones de SYSTEM2 del apéndice \ref{codigo:suma}}
\label{modelo:suma:system2}
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=24 cm, angle=90]{img/fact.png}
\caption{Calculo del factorial de 3 visto en la seccion \ref{fig:factorial}}\label{modelo:grafo}
\end{center}
\end{figure}

Un ejemplo mas complejo puede verse en la figura \ref{modelo:grafo}, fue utilizado para comprobar que el ejemplo estaba realmente calculando el factorial de 3. La captura fue realizada utilizando el comando \verb=:probe SYSTEM= en \FDR utilizando el código de factorial del apéndice \ref{codigo:factorial}.

\subsubsection*{Refinamiento}

En \FDR para probar si el conjunto de trazas de \verb=P= es un refinamiento del conjunto de trazas \verb=Q= se escribe \verb$assert P [T= Q$. En caso de querer utilizar fallas y divergencias se debería notar \verb$assert P [T= Q$. Para hacer una prueba de refinamiento se utiliza el ejemplo de la cola visto en la sección \ref{ejemplo:cola}. El código en \CSPm de este se encuentra en el apéndice \ref{codigo:cola}. El mismo cuenta con dos actores ``main'', \verb=actor_main1= y \verb=actor_main2=, donde: el actor \verb=actor_main1=, después de crear un actor \verb=Queue=, hace uso de la selección interna para:
\begin{itemize}
 \item enviar al actor \verb=Queue= un mensaje $['enqueue', 1]$
 \item enviar al actor \verb=Queue= un mensaje $['enqueue', 2]$
 \item enviar al actor \verb=Queue= un mensaje $['dequeue', buzonDeMain]$, seguido de esperar recibir un entero.
\end{itemize}

El actor \verb=actor_main2=, después de crear un actor \textit{Queue}, hace uso de la selección interna para:
\begin{itemize}
 \item enviar al actor \verb=Queue= un mensaje $['enqueue', 1]$, seguido de enviar al actor \textit{Queue} un mensaje $['enqueue', 2]$
 \item enviar al actor \verb=Queue= un mensaje $['dequeue', buzonDeMain]$, seguido de esperar recibir un entero.
\end{itemize}

El resultado de poner en paralelo todos los componentes del sistema utilizando \verb=actor_main1= se llama \verb=SYSTEM1=. En el caso de \verb=actor_main2= se llama \verb=SYSTEM2=. Esto puede verse en el código de \CSPm en el apéndice \ref{codigo:cola}.

\begin{figure}
\begin{center}
\includegraphics[width=5 cm]{img/trazas.png}
\caption{Resultado de las afirmaciones}\label{modelo:verifica}
\end{center}
\end{figure}

Para probar si \verb$SYSTEM1$, refina en \verb$SYSTEM2$ se utiliza la siguiente afirmación: \verb$assert$ \verb$SYSTEM1 [T= SYSTEM2$. Para probar si \verb$SYSTEM2$, refina en \verb$SYSTEM1$ se utiliza la siguiente afirmación: \verb$assert SYSTEM2 [T= SYSTEM1$.

Puede verse en la figura \ref{modelo:verifica} el resultado de correr ambas afirmaciones. Utilizando la herramienta se encuentra un contraejemplo donde \verb$SYSTEM2$ no refina en \verb$SYSTEM1$ como muestra la figura \ref{modelo:contraejemplo}.

La intuición detrás de por qué \verb$SYSTEM1$ refina en \verb$SYSTEM2$, y que \verb$SYSTEM2$ no refina en \verb$SYSTEM1$ tiene que ver con que \verb$SYSTEM1$ es menos restrictivo que \verb$SYSTEM2$. El actor \verb=actor_main1= puede elegir entre entre dos opciones para desencolar, y el actor \verb=actor_main2= solo una y con un orden preestablecido.

Si bien la descripción anterior solo contempla el caso del chequeo de refiniamiento utilizando el modelo de trazas, en el apéndice \ref{codigo:cola} pueden verse ambas aserciones.

\begin{figure}
\begin{center}
\includegraphics[width=15 cm]{img/contraejemplo.png}
\caption{Contraejemplo de SYSTEM2 no refina en SYSTEM1}\label{modelo:contraejemplo}
\end{center}
\end{figure}
 
