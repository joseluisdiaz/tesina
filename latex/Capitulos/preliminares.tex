\chapter{Preliminares}

En este capítulo, en la primera sección se explora algunas particularidades del paralelismo en \CSP, tales como: paralelismo sincrónico, alfabetizado, entrelazado y generalizado. En la segunda sección se muestra algunas construcciones en \CSPm que resultan útiles. 

La sección de \CSP no pretende ser una introducción al lenguaje, se asume que el lector tiene cierta familiaridad con él. Para una introducción se puede consultar \cite{Cristia:CSP}, para una referencia completa \cite{Roscoe:1997:TPC:550448}

\section{Paralelismo en CSP}

En esta sección se muestra en \CSP se puede en solo sincronizar algunos eventos. Para estudiar sistemas concurrentes es útil tener un control mas fino de que eventos son de interés. 

\subsubsection*{Paralelismo sincrónico}

El operador más simple de \CSP es el que está dispuesto a sincronizar todos los eventos. Es decir, ambos procesos compuestos por este operador avanzan cuando encuentran un evento que ambos están dispuestos a sincronizar. Por ejemplo:

\begin{align*}
P_1 =& a \then P_1\\
P_2 =& a \then P_2 \\
SYSTEM =& P_1 \parallel P_2
\end{align*}

donde $P_1$ y $P_2$ sincronizan con el evento $a$. Cuando utilizamos procesos parametrizados muchas veces es útil enviar información. El siguiente ejemplo muestra esto:

\begin{align*}
P_1 =& canal!1 \then STOP \\
P_2 =& canal?x \then P(x) \\
SYSTEM =& P_1 \parallel P_2 \\
\end{align*}

Donde $canal!1$ y que $canal?x$ lo recibe. Para entender un poco más cómo funciona la notación que involucra $\langle ? \rangle$ y $\langle ! \rangle$, supongamos que $x$ puede tomar los valores $1$, $2$ y $3$. La expresión $canal?x$ equivale a un proceso que está dispuesto a sincronizar con todos estos potenciales valores:
\begin{align*}
P_2 & =  canal.1 \then STOP \\
      & \Extchoice canal.2 \then STOP \\
      & \Extchoice canal.3 \then STOP 
\end{align*}

y qué $P_1$ equivale a: 

\begin{align*}
P_1  = canal.1 \then STOP \\
\end{align*}

Como $x$ es una variable libre, y el evento que termina sincronizando es $canal.1$ esta toma el valor $1$. En realidad el paso de información es ficticio todo el tiempo se está sincronizando en eventos.

\subsubsection*{Paralelismo alfabetizado}

Mientras más procesos combinemos utilizando el operador $\parallel$, más procesos tienen que ponerse de acuerdo en los eventos a sincronizar, ponemos en paralelo los procesos $P$ y $Q$ no necesariamente todas las comunicaciones de $P$ son para $Q$.

Si $X$ e $Y$ son dos conjunto de eventos, $P\ \textsubscript{X}\parallel\textsubscript{Y}\ Q$ es la combinación en donde $P$ tiene solo permitido comunicar los eventos $X$ y donde $Q$ tiene sólo permitido comunicar los eventos $Y$, y únicamente tienen que ponerse de acuerdo en la intersección $X \cap Y$. Por ejemplo:

\[ 
 ( a \then b \then b \then STOP )\  \textsubscript{\{a, b\}} \parallel \textsubscript{\{b, c\}}\ ( b \then c \then b \then STOP ) 
\]

Se comporta como:

\[ 
 ( a \then b \then c \then b \then STOP )
\]

\subsubsection*{Entrelazado}
Los operadores $\parallel$ y $\textsubscript{X}\parallel\textsubscript{Y}$ tienen la propiedad que todos los procesos involucrados tienen que sincronizar algún evento. Utilizando el operador entrelazado, cada proceso corre independiente de cualquier otro. Se nota $P \Interleave Q$.

\subsubsection*{Paralelismo generalizado}
Existe una forma general de escribir todos los operadores vistos utilizando el operador de paralelismo generalizado $P \Parallel\limits_{X} Q$. Donde $P$ y $Q$ solo tienen que ponerse de acuerdo en los eventos contenidos en $X$ y los eventos que están por fuera de $X$ se procesan independientemente.

Podemos escribir el operador de entrelazado usando la siguiente equivalencia:

\[
 P \Interleave Q = P \Parallel\limits_{\{\}} Q
\]

Podemos escribir el operador de paralelismo alfabetizado como:

\[
 P\ \textsubscript{X}\parallel\textsubscript{Y}\ Q = P \Parallel\limits_{X \cap Y} Q
\]

Si $\Sigma$ fueran todos los eventos posibles en un sistema dado podemos definir el operador de paralelismo sincrónico de la siguiente forma:

\[
 P \parallel Q = P \Parallel\limits_{\Sigma} Q
\]

\subsubsection*{Actores y CSP}

Como vimos en el capítulo anterior, \CSP es sincrónico, mientras que, el paso de mensajes o envío de comunicaciones en el sistema de actores no lo es. Si se quiere transmitir entre dos procesos información en \CSP lo escribimos (como vimos en \textit{Paralelismo sincrónico}), de la siguiente forma:

\begin{align*}
P_1 =& canal!1 \then STOP \\
P_2 =& canal?x \then STOP \\
SYSTEM =& P_1 \Parallel P_2  
\end{align*}

Para poder desacoplar el envío de la recepción del mensaje, se puede utilizar una estructura intermedia de $BUFFER$, cuya escritura es:

\begin{align*}
BUFFER =& enviar?x \then recibir!x \then BUFFER \\
P_1 =& enviar!1 \then STOP \\
P_2 =& recibir?x \then STOP \\
SYSTEM =& ( P_1 \Interleave P_2 ) \Parallel BUFFER \\
\end{align*}

Como la comunicación es desde $P_1$ hacia $BUFFER$ y desde $BUFFER$ hacia $P_2$, no hay ninguna comunicación entre $P_1$ y $P_2$. Por esto se utiliza el operador de entrelazado.

En \CSP no existe el concepto de instancia, y se debe definir la red de procesos desde el comienzo. Para iniciar $n$ procesos de tipo $P$ se escriben los siguientes procesos en \CSP:

\begin{align*}
P =& \texttt{comportmiento-de-P} \then STOP \\
P_1 =& Iniciar_1 \then P \\
P_2 =& Iniciar_2 \then P \\
&\ldots \\
P_n =& Iniciar_n \then P \\
SYSTEM =& P_1 \Interleave P_2 \Interleave \ldots \Interleave P_n
\end{align*}

Con estas estructuras, se tienen los elementos básicos para poder crear un proceso y enviar una comunicación de manera asincrónica. Se puede ver esto en el siguiente ejemplo:

\begin{align*}
BUFFER_1 &= enviar.1?x \then recibir.1!x \then BUFFER_1\\
BUFFER_2 &= enviar.2?x \then recibir.2!x \then BUFFER_2\\
SUMA &= inicia_{suma} \then recibir.1?x \then enviar.2?(x + 1) \then STOP \\
CLIENTE &= inicia_{suma}\then enviar.1!2 \then recibir.2?x \then STOP \\
BUFFER &= BUFFER_1 \Interleave BUFFER_2 \\
SYSTEM &= (SUMA \Parallel\limits_{\{inicia_{suma}\}} CLIENTE) \Parallel\limits_{Y}\ BUFFER
\end{align*}

En el ejemplo anterior, $CLIENT$ inicia el proceso $SUMA$, y le envía un dos. Este envío es asíncrono por $BUFFER_1$. Cuando $SUMA$ recibe este dos, crea una nuevo mensaje y se lo envía a $CLIENTE$ de manera asincrónica, con el valor que recibió incrementado en uno. En la composición de $SYSTEM$ se puede ver que el único evento que se sincroniza entre $SUMA$ y $CLIENTE$ es $inicia_{suma}$. En el otro operador paralelo los valores de $Y$ vienen dado por los eventos en los que la composición de $SUMA$ y $CLIENT$ sincronizan con $BUFFER$. Para esto deberíamos saber que valores puede tomar $x$, asumiendo que toma los valores $1$, $2$ y $3$. Los eventos a sincronizar serían el conjunto generado por $recibir.m.n$ con $m = 1 \ldots 2$  y $n = 1 \ldots 3$ unión $enviar.m.n$ con $m = 1 \ldots 2$  y $n = 1 \ldots 3$, es decir todos los eventos inherentes a $BUFFER$.

Este último ejemplo muestra dos de los aspectos que se desarrollaran en el capitulo siguiente: como desacoplar el envío de mensajes y como simular la creación de un proceso. También puede verse el uso de los distintos operadores paralelo.
 
\section{El lenguaje CSPm}

\CSPm es un lenguaje funcional, que tiene una integración para definir procesos de \CSP. También permite realizar aserciones sobre los procesos de \CSP resultantes. Este lenguaje es el que utiliza la plataforma \FDR. En esta sección se describirán algunas de las construcciones de \CSP en \CSPm y algunas construcciones propias de \CSPm.

\subsubsection{Tipos algebraicos}

Permite declarar tipos estructurados, son similares a las declaraciones de tipo \textit{data} de Haskell. La más simple de las declaraciones es utilizando constantes.

\begin{lstlisting}[language=cspm, style=sinnumeros]
datatype ColorSimple = Rojo | Verde | Azul
\end{lstlisting}

Esto declara Rojo, Verde y Azul, como símbolos del tipo Color, y vincula Color al conjunto \{Rojo, Verde, Azul \}. Estos tipos de datos puede tener parámetros. Por ejemplo, se pude agregar un constructor de datos RGB, a saber:

\begin{lstlisting}[language=cspm, style=sinnumeros]
datatype ColorComplejo = Nombre.ColorSimple | RGB.{0..255}.{0..255}.{0..255}
\end{lstlisting}

Esto declara Nombre, como un constructor de datos, de tipo $ColorSimple \Rightarrow ColorComplejo$ y a $RGB$ como un constructor de datos de  tipo $Int \Rightarrow Int \Rightarrow Int \Rightarrow ColorComplejo$ y ColorComplejo es el conjunto:
\begin{multline*}
\{ Nombre.c | c \leftarrow  ColorSimple \} \cup \{ RGB.r.g.b |  r \leftarrow \{ 0 \dots 255 \},  g \leftarrow \{ 0 \dots 255 \}, \\  b \leftarrow \{ 0 \dots 255 \} \}  
\end{multline*}

Si se declara un tipo de datos T, entonces a T se adjunta el conjunto de todos los valores de tipo de datos posibles que se pueden construir. 

\subsubsection{Canales}

Los canales de \CSPm son utilizados para crear eventos, y se declaran de una manera similar a los tipos de datos. Por ejemplo:

\begin{lstlisting}[language=cspm, style=sinnumeros]
channel estaListo
channel x, y : {0..1}.Bool
\end{lstlisting}

Declara tres canales, uno que no toma parámetros (listo es de tipo Event), y dos que tienen dos componentes. Cualquier valor del conjunto \{0,1\} y un booleano. El conjunto de los eventos definidos es el siguiente: \{ estaListo, x.0.false, x.1.false, x.0.true, x.1.true, y.0.false, y.1.false, y.0.true, y.1.true \}. Estos eventos pueden ser parte de la declaración de procesos como por ejemplo \lstinline[language=cspm, style=sinnumeros]{P = x?a?b -> STOP}.

\subsubsection{Búsqueda de patrones}

Es posible en \CSP que los valores puedan ser buscados por coincidencia de patrones. Por ejemplo, la siguiente función toma un entero, se puede usar la búsqueda de patrones para especificar un comportamiento diferente dependiendo de este argumento:

\begin{lstlisting}[language=cspm, style=sinnumeros]
f(0) = True
f(1) = False
f(_) = error("Error")
\end{lstlisting}

Funciona de manera similar a Haskell, también se pueden utilizar otras construcciones como secuencias o algún tipo algebraico.

\subsubsection{Operadores replicados}
\FDR tiene una versión replicada o indexada de alguno de sus operadores. Estos proveen una forma simple de construir un proceso que consiste en una serie de procesos compuestos utilizando el mismo operador. Por ejemplo se define P de la siguiente manera:, \lstinline[language=cspm, style=sinnumeros]{P :: (Int) -> Proc} luego, \lstinline[language=cspm, style=sinnumeros]=||| x: { 0..2 } @ P(x) = evalúa P para cada valor de x en el conjunto dado y los compone utilizando el operador de entrelazado. Por lo tanto, lo anterior es equivalente a \lstinline[language=cspm, style=sinnumeros]{P (0) ||| P (1) ||| P (2)}.


La forma general de un operador replicado es:

\begin{lstlisting}[language=cspm, style=sinnumeros]
op <declaraciones> @ P
\end{lstlisting}

donde op es operador, puede ser el de entrelazado, selección interna, etc. Las declaraciones son una lista de declaraciones y P es la definición de proceso, este puede hacer uso de las variables definidas por las declaraciones. Cada uno de los operadores evalúa P para cada valor que toman las declaraciones antes de componerlas juntas usando op.


\subsubsection{Otras construcciones}
En esta sección se muestran algunas de las conversiones útiles para entender un programa en \CSPm.

Tabla de conversión para secuencias:

\begin{center}
\begin{tabular}{ l l }
  $\seq$ a & \verb|Seq(a)| \\
  $\nil$ & \verb|< >| \\
  $\langle 1, 2, 3 \rangle$ & \verb|<1,2,3>| \\
  $\Nil s$ & \verb=Null(s)=
  \\
  $s \cat t$ & \verb=s^t=
  \\
  $\# s$ & \verb|#s|
  \\
  $head~s$ & \verb|head(s)|
  \\
  $tail~s$ & \verb|tail(s)|
  \\
  $\dcat s$ & \verb|concat(s)|
  \\
  $x \elem s$ & \verb=elem(x,s)=
  \\
  $\ran s$ &  \verb|set(s)|
  
\end{tabular}
\end{center}

Tabla de conversión para la definición de procesos:

\begin{center}
\begin{tabular}{ l l }
  Stop & \verb=STOP= \\
  Skip & \verb=SKIP= \\
  $c \then p$ & \verb=c -> p= \\
  $c ? x  \then p$  & \verb=c?x -> p= \\
  $c ! v \then p$ & \verb=c!v -> p= \\
  $p \extchoice q$ & \verb=p [] q= \\
  $p \intchoice q$ & \verb=p |~| q= \\
  $p \interleave q $ & \verb=p ||| q= \\
  $p \parallel q $ & \verb=p || q= \\
  $p\ \textsubscript{X} \parallel \textsubscript{Y}\ q$ & \verb=p |[|X|]| q= \\
  $p \Parallel\limits_{X} q$ & \verb=p |[x||y]| q= \\
  \end{tabular}
\end{center}

