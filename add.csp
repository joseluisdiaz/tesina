N_PROC = 2
PID = {1 .. N_PROC}

MAX_INT = 10
V = {0 .. MAX_INT}

datatype SmallInt = SI.V | Overflow

datatype ActorName = F | G

datatype M = T.PID | Value.SmallInt | None

-- channel Comm:Tag.(M,M)
channel Start:ActorName.PID.(M,M)

channel CommEx:PID.(M, M)
channel CommIn:PID.(M, M)

channel newPid:PID

mailbox(i,  <>) = CommEx?i.x -> mailbox(i, <x>)
mailbox(i, <x>) = CommIn!i.x -> mailbox(i,<>) [] CommEx?i.y -> mailbox(i, <x, y>)
mailbox(i, <x,y>) = CommIn!i.x -> mailbox(i,<y>) [] CommIn!i.y -> mailbox(i, <x>)

table = pidtable(< 1 .. N_PROC >)
pidtable(<>) = STOP
pidtable(list) =
  let
    x = head(list)
    xs = tail(list)
  within
   newPid!x -> pidtable(xs)

--
add(SI.a, SI.b) = let sum = a + b within if sum <= MAX_INT then SI.sum else Overflow
add(_, _) = Overflow
--

f(m) = Start?F.m.(None, None) -> started_f(m)
started_f(m) =
  newPid?t ->
  Start!G.t.(T.m, Value.SI.2) ->
  CommIn?m.(Value.V, None) ->
  started_f(m) -- (same Behaviour)
started_f(_) = STOP
--
g(m) = Start?G.m.(a,v) -> started_g(m,a,v)
started_g(m, T.a1, Value.v) = CommEx!a1.(Value.(add(v, SI.1)), None) -> g(m) -- (botton Behaviour)
started_g(_, _, _) = STOP
--
h = newPid?t -> Start!F.t.(None, None) -> STOP
--
Starts(actor) = { Start.actor.t.(v1, v2) | t <- PID, v1 <- M, v2 <- M }
--
CommsInt(t) = { CommIn.t.(v1, v2) | v1 <- M, v2 <- M } -- las comuncaciones internas son sola para Ã©l
AllCommsInt = { CommIn.t.(v1, v2) | t <- PID, v1 <- M, v2 <- M }
CommsExt = { CommEx.t.(v1, v2) | t <- PID, v1 <- M, v2 <- M }
Comms(t) = union(CommsInt(t), CommsExt)
--
AllComms = union(AllCommsInt, CommsExt)
NewPids = { newPid.i | i <- PID }

--
fs = || i:PID @ [union(Starts(G), union(NewPids, union(Starts(F), Comms(i)))) ] f(i)
gs = || i:PID @ [union(Starts(G), Comms(i))] g(i)
xxx = Starts(F)

mailboxs = || i:PID @ [Comms(i)] mailbox(i, <>)

--
SYSTEM = ((( fs [|Starts(G)|] gs ) [|xxx|] h) [|AllComms|] mailboxs) [|NewPids|] table
