N_PROC = 3
PID = {1 .. N_PROC}

MAX_INT = 2
V = {0 .. MAX_INT}

datatype SmallInt = SI.V | Overflow

datatype ActorName = F | G

datatype M = T.PID | Value.SmallInt | None

channel Start:ActorName.PID.(M,M)
channel StartEx:ActorName.PID.(M,M)

channel CommEx:PID.(M, M)
channel CommIn:PID.(M, M)

channel newPid:PID

mailbox(i,  <>) = CommEx?i.x -> mailbox(i, <x>)
mailbox(i, <x>) = CommIn!i.x -> mailbox(i,<>) [] CommEx?i.y -> mailbox(i, <x, y>)
mailbox(i, <x,y>) = CommIn!i.x -> mailbox(i,<y>) [] CommIn!i.y -> mailbox(i, <x>)

start(<>) = StartEx?x -> start(<x>)
start(<x1>) = Start!x1 -> start(<>) [] StartEx?x2 -> start(<x1, x2>)
start(<x1, x2>) = Start!x1 -> start(<x2>) [] StartEx?x2 -> start(<x1>)


table = pidtable(< 1 .. N_PROC >)
pidtable(<>) = STOP
pidtable(list) =
  let
    x = head(list)
    xs = tail(list)
  within
   newPid!x -> pidtable(xs)

--
add(SI.a, SI.b) = let sum = a + b within if sum <= MAX_INT then SI.sum else Overflow
add(_, _) = Overflow
--
functionEnv = (| F => started_f, G => started_g |)

procStarter(m) = Start?PROC.m.(arg1, arg2) -> mapLookup(functionEnv, PROC)(m, arg1, arg2)

started_f(m, None, None) =
  newPid?t ->
  StartEx!G.t.(T.m, Value.SI.0) ->
  CommIn?m.(Value.V, None) ->
  started_f(m, None, None) -- (same Behaviour)
started_f(_, _, _) = STOP
--
started_g(m, T.a1, Value.v) =
  CommEx!a1.(Value.(add(v, SI.1)), None) ->
   STOP -- (botton Behaviour)
started_g(_, _, _) = STOP
--
h = newPid?t -> StartEx!F.t.(None, None) -> STOP
--

actors = ||| i:PID @ procStarter(i)
mailboxs = ||| i:PID @ mailbox(i, <>)
-- --
ACTORS = ( actors ) ||| h
RUNTIME = mailboxs ||| start(<>) ||| table

Comms = {|CommIn, CommEx|}
Starts = {|StartEx, Start|}
SYSTEM = ACTORS [|union({|newPid|}, union(Comms, Starts))|] RUNTIME


assert SYSTEM :[deadlock free [F]]
