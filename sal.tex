\documentclass[fleqn]{article}

\usepackage[utf8]{inputenc}
\usepackage{cite}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{hyperref}
\usepackage{syntax}
\usepackage{listings}
\usepackage{zed-csp}


\usepackage{tikz}
\usetikzlibrary{positioning}

\lstdefinelanguage{sal}{
  keywords = {send, become, let, new, in, to, if, then, else, case, def, end, case, of}
}

\lstdefinelanguage{csp}{
  keywords = {channel, datatype}
}

\lstdefinestyle{simple}{
  basewidth=0.5em
}



\title{CSP}
\author{José Luis Diaz}
\date{ }
 
\begin{document}
 
\maketitle
 
\tableofcontents
 
\section{Introducción}

\section{Conceptos básicos}

\subsection*{Comportamientos}

\subsection*{Creando Actores}

\subsection*{Creando comunicaciones}

\subsection*{Comandos}

\section{Lenguaje de Actor Mínimo}

Este lenguaje fue mostrado por primera vez en la tesis doctoral de Agha
\cite{Agha:1986:AMC:7929}, fue concebido como un lenguaje con fines pedagógicos.
Un programa en sal está compuesto por un conjunto \textit{Comportamientos}.
Como la mayoría de los lenguaje de programación, se agrega un
\textit{Comportamiento} llamado \textbf{main} como punto de entrada, está es una
adaptación de está tesina que no estaba originalmente.

\subsection{Comportamientos}

La sintaxis de los comportamientos es la siguiente:

\begin{grammar}
  <behavior> :== `def' <beh name> `(' <param-list> `)' `[`'<communication-list>`]' \\
            <command>* \\
  `end def'
\end{grammar}

La construcción \textit{param-list} es una lista de identificadores separados por coma,
se inicializan cuando el actor es creado. Por otra parte,
\textit{communication-list} contiene la comunicación a ser procesada por el
actor, esta puede ser una lista de identificadores.
Muchas veces dependiendo del tipo de comunicación que se esté enviando,
por ejemplo si el actor esta simulando ser una caja de ahorros, y recibe
un mensaje de \textbf{retirar} el mensaje debería contener la cantidad, pero en
caso de una consulta de saldo \textbf{balance} no debe especificar ningún parámetro
adicional, para esto se bifurca por el valor de uno de los campos llamado
\textbf{tag-field}, la sintaxis de esta puede  la siguiente:

\begin{grammar}
  <params> ::= <id> | <id> `,' <params>
  <var-list> ::= `case' <tag-field> `of' <variant>+ `end case'
  <variant> ::= <case label> `:' <params>
\end{grammar}

El siguiente ejemplo muestra un caso donde es útil utilizar la sintaxis basada
en \textbf{case}:

\begin{lstlisting}[language=sal, style=simple]
case pedido of 
  depositar: (cliente, monto) 
  retirar: (cliente, monto) 
  balance: (cliente) 
end case
\end{lstlisting}

No siempre es necesario utilizar esta sintaxis, \textit{communication-list} puede tener
la misma estructura que \textit{param-list}.

\subsection{Comandos}
La gramática de los comandos en SAL es la siguiente:

\begin{grammar}
  <command> ::= `send' $e_1, e_2, ..., e_n$ `to' <actor>  
  \alt `become' $B(e_1, e_2, ..., e_n)$
  \alt `let' $x_1$ = `new' $B_1(e_1, e_2, ..., e_{1n})$, \\
  ... $x_k$ = `new' $B_k(e_1, e_2, ..., e_{kn})$        \\
  `in' <command> 
  \alt `if`<bool-expr> `then' <command> `else' <command> `end if' 
  \alt <command> `;' <command>
\end{grammar}

\begin{description}
\item [send]  Este comando permite enviar mensajes a otros actores, toma como
  parámetro una lista separada por coma de las expresiones a enviar, y el actor
  destino, el envío de mensajes es asincrónico. Cada expresión es evaluada antes
  de ser enviada.
\item [become] Este comando especifica el siguiente comportamiento del actor
  que está procesando la comunicación recibida. Como en el caso anterior se evalúan
  las expresiones antes de ser enviadas, y estas aparecerán como la listas de
  parámetros del comportamiento. 
\item[new] Este comando sirve para crear nuevos actores. El alcance de los
  identificadores de los nuevos actores creados está sujeto a el cuerpo a del \textbf{let}.
\item[condicional] Luego de evaluar la expresión booleana, si es verdadera
  ejecuta lo que esta a continuación del \textbf{then}, en caso contrario lo que está a
  continuación del \textbf{else}. Funciona como cualquier condicional.
\item[secuenciación] Los comandos en sal ocurren al mismo tiempo, en este
  sentido podrían pensarse que los comandos de un comportamiento ocurren en paralelo.
  
\end{description}

\subsection{Expresiones}

Existen tres tipos primitivos, booleanos, enteros y dirección del buzón. Las operaciones
posibles entre los booleanos, \textbf{or}, \textbf{and}, \textbf{not}. Con
respecto a los enteros se pueden operar utilizando \textbf{+}, \textbf{-},
\textbf{*}, \textbf{/}. Un buzón es un identificador que es devuelto cuando se
crea un nuevo actor.

\subsection{Ejemplo: cálculo de factorial en SAL}

Está implementación del factorial está adaptada de \cite{Agha:1986:AMC:7929}, esta
depende de un actor \textit{main} que le envía el valor a calcular. El factorial
esta siempre disponible para procesar la siguiente comunicación, no bloquea con
el calculo recursivo del factorial sino que lo delega en otros actores.

La palabra reservada \textit{self} hace referencia a la dirección de buzón
correspondiente al actor que está procesando la comunicación, este es inicializado
cuando el actor es creado.

\begin{lstlisting}[language=sal, style=simple]
def Factorial()[val, customer]
  if val = 0 then
 send [1] to customer
  else
    let cont = new FactorialCont(val, customer)
       in send [val - 1, cont] to self
  end if
  become Factorial()
end def

def FactorialCont(n, customer)[arg] 
  send [n * arg] to customer
end def
\end{lstlisting}

El actor ante un entero distinto de cero ejecuta dos acciones, crea un actor con
un comportamiento que será multiplicar por \textbf{n} el valor recibido y
enviarlo al buzón de quien pidió el calculo del factorial de \textbf{n}.
También, se envía un mensaje a si mismo para evaluar el factorial de \textbf{n -
  1} y que le envíe el valor al actor que se acaba de crear. Este empeoramiento
se puede ver en la figura \ref{fig:factorial}.
En caso de que reciba \textbf{0} se le enviara \textbf{1} a quien pidió el
calculo del factorial.

\begin{figure}
\begin{tikzpicture}
\draw[thick] (8,7) -- (8, 0.5);

\node[] (a1) at (8,7.3) {(a, Factorial(a))};

\node[align=center, right] (a1) at (8.1,6.5) {[3,c]};
\draw[fill] (8,6.5) circle (3pt);

\node[align=center, right] (a2) at (8.1,5) {[2,c1]};
\draw[fill] (8,5) circle (3pt);

\node[align=center, right] (a3) at (8.1,3.5) {[1,c2]};
\draw[fill] (8,3.5) circle (3pt);

\node[align=center, right] (a4) at (8.1,2) {[0,c3]};
\draw[fill] (8,2) circle (3pt);

\draw[-latex] (a1.west) to[bend left] (a2.west);
\draw[-latex] (a2.west) to[bend left] (a3.west);
\draw[-latex] (a3.west) to[bend left] (a4.west);

\node[] (d1) at (0.5,6.5) {(c1, FactorialCont(3,c))};
\draw[thick] (d1.south) -- (0.5, 0.5);

\node[] (c1) at (3,5.1) {(c2, FactorialCont(2,c1))};
\draw[thick] (c1.south) -- (3, 0.5);

\node[] (b1) at (5.5,3.65) {(c3, FactorialCont(1,c2))};
\draw[thick] (b1.south) -- (5.5, 0.5);


\draw[fill] (5.5,1.8) circle (2pt);
\node[align=center, right] (b2) at (5.5,1.5) {[1]};

\draw[fill] (3,1.6) circle (2pt);
\node[align=center, right] (c2) at (3,1.3) {[1]};

\draw[fill] (0.5,1.4) circle (2pt);
\node[align=center, right] (d2) at (0.5,1.1) {[2]};

\draw[-latex, thick] (8,2)  -- (5.5,1.8);
\draw[-latex, thick] (5.5,1.8) -- (3,1.6);
\draw[-latex, thick] (3,1.6) -- (0.5,1.4);
\draw[-latex, thick] (0.5,1.4) -- (-1,1.4);

\draw[-latex, black, dashed] (a1.west) -- (d1.south);
\draw[-latex, black, dashed] (a2.west) -- (c1.south);
\draw[-latex, black, dashed] (a3.west) -- (b1.south);

\end{tikzpicture}
\caption{El diagrama ilustra el cálculo del factorial de 3, todo el resultado es
enviado al actor \textit{c}. Las lineas en punto indican la creación de un actor.}
\label{fig:factorial}
\end{figure}

\section{CSP y actores}
Para empezar a describir como se modeló en CSP, primero es importante hacer
referencia a que se utilizó \textit{CSPm} \cite{fdr}, que combina los operadores de \textit{CSP}
originalmente propuesto por Hoare\cite{Hoare:1978:CSP:359576.359585}, y un lenguaje funcional.

En el proceso de traducción de \textit{SAL} a \textit{CSPm}, fue necesario construir un pequeño
\textit{runtime} para emular como los actores corren. Recordemos que la
naturaleza de \textit{CSP} es síncrona y los actores no lo son. Fue necesario
concretamente desacoplar la creación de nuevos actores, el envío y la recepción de mensajes. 

\subsection{Creación de nuevos actores}

Para desacoplar la creación de actores se utilizan varias abstracciones, en particular
\textbf{ActorID} y dos canales de \textit{CSP}.

Para definir \textbf{ActorID} utilizaremos tipos algebraicos parecidos a los de
haskell, soportados por \textit{CSPm}.

\[
datatype\ ActorID = Factorial.\{1\} | FactorialWorker.\{1,2,3\} | Main.\{1\}
\]

Este tipo introduce y nombra cada uno de los actores que van ser utilizados,
Aparte de incluir el nombre, también encapsula la cantidad de actores de un tipo
dado.
Para esto se utiliza la notacíon de conjunto que vemos entre llaves, en este
caso vamos a contar con un actor del tipo \textbf{Factorial}, tres del tipo
\textbf{FactorialWorker} y uno más del tipo \textbf{Main}.


\[
channel\ CreateAsk:ActorID.(Value, Value)\\
channel\ Create:ActorID.(Value, Value)
\]

Estos dos canales son los encargados de desacoplar la creación de un nuevo
actor. Aquí se introduce \textbf{Value}, un tipo de datos algebraico que
representa los valores que van ser pasado tanto en la creación de actores como en
el envío de mensajes. Los posibles valores a utilizar son enteros, \textbf{ActorID} o
\textbf{ATOMS}, este último se usa para denominar un tipo de cadena de
caracteres \footnote{//TODO: Agregar un apéndice mostrando todo el runtime?}. 

Para desacoplar el actor que tiene la intención de crear otro del creado, el primero
espera a sincronizar en un evento del tipo $CreateAsk$, como existe un proceso
auxiliar que está dispuesto encontrase con el, se libera y así puede continuar
el proceso que crea el nuevo actor. En realidad, la creación es algo ficticio ya
que tenemos una red de procesos \textit{CSP} esperando el evento $Create$ para
arrancar con el comportamiento definido.

\[
CreateAsk!FactorialWorker.1?m \then Create.FactorialWorker.1!m \then \Stop\\
CreateAsk!FactorialWorker.2?m \then Create.FactorialWorker.2!m \then \Stop\\
CreateAsk!FactorialWorker.3?m \then Create.FactorialWorker.3!m \then \Stop
\]


Este proceso simplemente espera a sincronizar con un evento de tipo
\textit{CreateAsk} y emite un evento de tipo \textit{Create}.
En la semántica de CSP cuando utilizamos \textbf{`?'} estamos esperando un
evento en un canal, si utilizamos \textbf{`!'} estamos enviando. Esto es una
notación ya que originalmente \textit{CSP} solo habla de dos procesos que se
encuentran en un punto dado.

En el ejemplo se puede ver que se envía el valor $FactorialWorker.1$ a quien esté
dispuesto a sincronizar, y se recepciona $m$ que es la tupla de valores antes
vista. Este punto es muy importante ya que se le esta enviando al proceso
que tiene la intención de crear un actor la dirección del buzón del nuevo actor
creado. Luego se espera a sincronizar con $Create.FactorialWorker.1$ a quien se
le envía el valor de $m$.

Esto no desacopla la creación que sino que, al mismo tiempo, La asignación de un
único nombre al actor. En este caso es el valor que se envía mediante
$CreateAsk$.

\subsection{Envío de mensajes}
Para desacoplar el envío de mensajes utilizamos una estructura intermedia que
actúa de \textit{buzón}, para comunicarase con esta estructura existen dos canales.

\[
channel\ CommSend:ActorID.(VALUE, VALUE)\\
channel\ CommRecv:ActorID.(VALUE, VALUE)
\]

Por cada actor en la red, existe un \textit{buzón} con el mismo \textbf{ActorId}
asociado a este. 
Un actor se bloquea esperando en $CommRecv$, cuando una nueva comunicación está
dispuesta a ser sincronizada, desde el \textit{buzón} hacia el actor esta es procesada.

Un \textit{buzón} puede guardar más de un mensaje en su interior. Esto
introduce un tipo de no determinismo, un actor puede sincronizar con cualquiera
de los mensajes disponibles en su \textit{buzón}.

El comportamiento del proceso buzón depende de su estado, si no tiene ningún
mensaje, si tiene algunos mensajes, o si está completo.
\begin{itemize}
\item Si no tiene ningún mensaje, solo sincroniza mensajes por el canal $CommSend$.
\item Si tiene algunos mensajes, por los canales $CommSend$ y $CommRecv$.
\item Si está completo, solo por el canal $CommRecv$.
\end{itemize}

Puede que los nombre de los canales suenen poco intuitivos, es importante notar que
provienen de la acciones vista desde los actores.

\begin{description}
\item [CommSend] Canal utilizado para comunicar desde cualquier actor hacia el buzón.
\item [CommRecv] Canal utilizado para comunicar del buzón hacia el actor asociado.
\end{description}

\subsection{Definición de comportamientos}
Para mostrar como funciona se utilizará un ejemplo simple, un actor que cuando
es creado recibe un parámetro del tipo \textbf{ActorId}, luego se queda esperando un
mensaje, cuando lo recibe, incrementa en uno el valor que este y lo envía al buzón de $a1$.

\[
  g = Create!G.1?(a1, None) \then g_{running}(G.1, a1) \\ 
g_{running}(self, ACTOR.client) = \\
\quad CommRecv.self!(INT.v, None) \then \\
\quad CommSend.client!(add(v, SI.1), None) \then \\ 
\quad g_{running}(self, ACTOR.client) \\
\]

Desarmando el ejemplo, una vez recibido el mensaje $Create!G.1?(a1, None)$,
podemos decir que el actor está \textit{Corriendo}, para marcar esta diferencia
se utiliza el proceso $g_{running}$.

Cuando un actor reacciona a una comunicación, tiene que definir el
comportamiento de reemplazo, en este caso puede ser el mismo comportamiento que
antes, o uno nuevo. Para esto útil separar, el actor antes de ser creado, del
actor que está corriendo. Sobre el final del ejemplo puede verse que se vuelve a
comportar como $g_{running}$.

Si no hubiera comportamiento de reemplazo simplemente la ultima linea sería
$\Stop$.

$CommRecv$ espera sincronizar con que el buzón propio al actor, cuando
recibe un mensaje, $CommSend.client$ envía una comunicación al buzón de $client$
el entero \footnote{Se utiliza una representación de enteros
  propios para evitar la explicación de estados que utilizar todos los enteros
  produce.} que recibió mas uno.


Para cerrar con esta idea, una implementación en \textit{SAL}.

\begin{lstlisting}[language=sal, style=simple]
def G(actor)[v]
    send [v + 1] to actor
end def
\end{lstlisting}

\subsection{Ejemplo: cálculo de factorial en CSPm}
Se utilizará el mismo ejemplo del factorial antes visto en sal \textbf{SAL},
está compuesto por dos comportamientos $Factorial$ y $FactorialWorker$.

\subsubsection*{Comportamiento de Factorial}

La primer parte del factorial es una suerte de preludio genérico que conecta un
actor que no está corriendo, o no fue creado con uno que fue creado. Esto es ya que
necesitamos arrancar toda la red de procesos en \textit{CSPm} en el momento de
comenzar la simulación.

\[
factorial = Create.Factorial.1?(None, None) \then factorial_{running}(Factorial.1) 
\]

En el caso de la formula anterior, espera a sincronizar con un mensaje de
creación. Esto no solamente simula la creación, sino que al mismo tiempo se
asigna el buzón con nombre $Factorial.1$ al actor que está corriendo. Dentro de
la definición del comportamiento hace referencia a $self$ como nombre de
su propio buzón.

Notar que en este caso solo necesita instanciar un solo actor de tipo $Factorial$.

\[
factorial_{running}(self) = CommRecv?self.(ACTOR.mailboxClient, INT.k) \then     \\
\textbf{if} (eq(k,SI.0)) \\
\quad  then \\
\quad \quad CommSend!mailboxClient.(INT.SI.1, None) \then factorialRunning(self) \\
\quad \textbf{else} \\
\quad \quad \textbf{let} \\
\quad \quad \quad newK = sub(k, SI.1) \\
\quad \quad \textbf{within} \\
\quad \quad \quad CreateAsk?FactorialWorker.pid!(INT.k, ACTOR.mailboxClient) \then \\
\quad \quad \quad CommSend!self.(ACTOR.FactorialWorker.pid, INT.newK)  \then \\
\quad \quad \quad factorial_{running}(self)
\]


El comportamiento del fragmento de código anterior es exactamente igual a él
código antes visto en \textit{SAL}. Cuando recibe un entero distinto de cero
ejecuta dos acciones, crea un actor \textbf{FactorialWorker} y se envía
un mensaje a si mismo para evaluar el factorial de \textbf{n - 1}.

En este caso el comportamiento de reemplazo para el buzón actual, es el mismo
que antes.

\subsubsection*{Comportamiento de FactorialWorker}

Antes de introducir el ejemplo, veamos como funciona la notación ${| |}$ de
\textit{CSPm}. Dado un tipo del $datatype T = A.{0..3}$, este es igual a
conjunto ${A.0, A.1, A.2, A.3}$, En vez de tener que enumerar todos los tipos de
$A$, podemos utilizar la notación ${|A|}$ que es equivalente.

En el caso del comportamiento de \textbf{FactorialWorker} vamos a necesitar
mas de un actor de este tipo, puede verse a continuación que se utiliza el operador de
interleaving de \textit{CSP} en conjunto con la notación anterior, para poner en
paralelo tantos procesos como elementos existan en el conjunto ${|FactorialWorker|}$.

\[
factorialWorker  = \Interleave_{x : \{|FactorialWorker|\}} Create!x?(k, mailboxClient) \\ 
\quad \then factorialWorker_{running}(x, k, mailboxClient)
\]

Utilizando esta notación el tipo de datos \textbf{ActorID}, tiene dos
responsabilidades: nombrar los actores y enumerarlos.
Recordemos que es necesario conocer la cantidad total de procesos que va
a tener un red de \textit{CSP} antes de comenzar la simulación.

\[
factorialWorker_{running}(self, INT.k, ACTOR.mailboxClient) = \\
CommRecv.self?(INT.n, None) \then \\
\quad \textbf{let} \\
\quad \quad val = mult(n, k) \\
\quad \textbf{within} \\
\quad \quad CommSend.mailboxClient!(INT.val, None) \then \\
\quad \Stop
\]


Este comportamiento es muy simple, en el momento de creación recibe dos
parámetros, un entero \textbf{k} y un dirección de un buzón, al momento de
recibir una comunicación, efectúa la multiplicación y se lo envía a
$mailboxClient$.
En este caso no cuenta con comportamiento de reemplazo, entonces termina con $\Stop$

\subsection{Ejemplo: Una pila en SAL}

Introducir el código en sal, y explicar como funciona.

\subsection{Ejemplo: Una pila en CSPm}

Introducir el código en CSPm equivalente y explicar las particularidades.

\subsection{Ejemplo: Un cliente-servidor de chat en SAL}

Introducir el código en sal, y explicar como funciona.

\subsection{Ejemplo: Un cliente-servidor de chat en CSPm}

Introducir el código en CSPm equivalente y explicar las particularidades.

\subsection{Traduciendo de SAL a CSPm}

Mostra la función que traduce de SAL a CSPm


TODO: Definir \textbf{translateExp}

La clase \textbf{Cmnd} con elementos de tipo S está dada por:

\begin{verbatim}
S :== S_1 ; S_2 | if b then S_1 else S_2 | send [e1, .., e_i] to a | become new
E(e_1, .. ,e_i) | let a_1 = new E_1(e_1,..,e_i) and ... a_j = new
E_1(e_1,..,e_i) { S } 
\end{verbatim}

definimos la funcion \textbf{translateCmd} de la siguiente forma:

\begin{verbatim}
translateCmd (S_1 S_2) = translateCmd(S_1) -> translateCmd(S_2)
\end{verbatim}


\begin{verbatim}
translateCmd(if b then S_1 else S_2) = 
   if (translateExp(b)) then
       translateCmd(S_1) else 
       translateCmd(S_2)
\end{verbatim}

\begin{verbatim}
translateCmd(send[e_1, ..., e_i] to a) = CommSend.a.
         (translateExp(e_1), ..., 
          translateExp(e_i)) 
\end{verbatim}

\begin{verbatim}
translateCmd(become new Beh(e_1, ..., e_n)) = runningBeh(self, e_1, ..., e_n)
\end{verbatim}

newEnv es el resultado de agregar a el entorno de las variables de mailbox $a_1
= E_1.pid_1$ .. $a_n = E_n.pid_n$
\begin{verbatim}
translateCmd(let a_1 = new E_1(e_1, ..., e_j) and 
         ... and a_n = new E_N(e_1, ..., e_j) { S } = 

CreateAsk?E_1.pid_1!(translateExp(e_1), ...,translateExp(e_j)) ->
CreateAsk?E_N.pid_n!(translateExp(e_1), ...,translateExp(e_j)) ->
translateCmd(S, newEnv)
\end{verbatim}


La clase \textbf{Beha} con elementos de tipo S está dada por:

\begin{verbatim}
def behName(a_1 .. a_i)[n_1 ... n_j]
  S
end def
\end{verbatim}

Tendria como equivalente en CSP:

\begin{verbatim}

behName = ||| actorId : {|BehName|} @ Create.actorId?(a_1, ..., a_i) ->
behNameRunning(actorId, a_1, .., a_n)

behNameRunning(self, a_1, .., a_n) = CommRecv.self(n_1 ... n_j) -> translateCmd(S)

\end{verbatim}

--- Agregar case? ---

\bibliography{references}{}
\bibliographystyle{plain}
\end{document}

