\documentclass[fleqn]{article}

\usepackage[utf8]{inputenc}
\usepackage{cite}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{hyperref}
\usepackage{syntax}
\usepackage{listings}

\lstdefinelanguage{sal}{
  keywords = {send, become, let, new, in, to, if, then, else, case, def, end, case, of}
}

\lstdefinelanguage{CSPm}{
  keywords = {send, become, let, new, in, to, if, then, else, case, def, end, case, of}
}

\lstdefinestyle{simple}{
  basewidth=0.5em
}


\begin{document}

\section{Conceptos básicos}

\subsection*{Comportamientos}

\subsection*{Creando Actores}

\subsection*{Creando comunicaciones}

\subsection*{Comandos}

\section{Lenguage de Actor Minimo}

Este lenguaje minimo fue mostrado por primera vez en la tesis doctoral
\cite{Agha:1986:AMC:7929}, fue consevido como un lenguaje  con fines pedagógicos.
Un programa en este lenguaje está compuesto por un conjunto de definiciones de
\textit{Comportamientos}. Como la mayoría de los lenguaje de programación,
se agrega un behavior llamado \textbf{main} como punto de entrada.
Estos definen el comportamiento concreto de cada actor en terminos de
expresiones y comandos.

\subsection{Expresiones}

Existen tres tipos primitivos, booleanos, enteros y mailbox. Las operaciones
posibles entre los booleanos, \textbf{or}, \textbf{and}, \textbf{not}. Con
respecto a los enteros se pueden operar utilizando \textbf{+}, \textbf{-},
\textbf{*}, \textbf{/}. Un mailbox es un identificador que es devuelto cuando se
crea un nuevo actor.

\subsection{Comandos}
La gramática de los comandos en SAL es la siguiente:

\begin{grammar}
  <command> ::= `send' $e_1, e_2, ..., e_n$ `to' <actor>  
  \alt `become' $B(e_1, e_2, ..., e_n)$
  \alt `let' $x_1$ = `new' $B_1(e_1, e_2, ..., e_{1n})$, \\
  ... $x_k$ = `new' $B_k(e_1, e_2, ..., e_{kn})$        \\
  `in' <command> 
  \alt`if`<bool-expr> `then' <command> `else' <command> `end if' 
  \alt<command> `;' <command>
\end{grammar}

\begin{description}
\item [send]  Este comando permite enviar mensajes a otros actores, toma como
  parametro una lista separada por coma de las expresiones a enviar, y el actor
  destino, el envio de mensajes es asincronico. Cada expresion es evaluada antes
  de ser enviada.
\item [become] Este comando especifica el siguiente comportamiendo del actor
  que está procesando el mensaje recicibido. Como en el caso anterior se evaluan
  las expresiones antes de ser enviadas, y estas apareceran como la listas de
  parametros del comportamiento. 
\item[new] Este comando sirve para crear nuevos. El alcance de los
  identificadores de los nuevos actores creados está sujeto a el cuerpo a
  el cuerpo del \textbf{let}.
\item[condicional] La expresion booleana tiene que ser evaluada, si es
\item[secuenciación] a diferencia de la semantica original de SAL, los
  comandos separados por punto y coma ocurren secuancialmente. \footnote{hoy
    tengo escrito que las cosas ocurran secuencialmente dentro del actor, ya que
  lo reemplazao usando ->, podría usar el operador de interleaving the CSP para
  guardar la semantica concreata originalmente propuesta por Agah.}
\end{description}
  verdadera tiene que ejecutarse el primer comando, en caso contrario el otro.
-- Agregar la idea de que los comandos ocurren en cualquier orden? ---

\subsection{Comportamientos}

La sintaxis de los comportamientos es la siguiente:

\begin{grammar}
  <behavior> :== `def' <beh name> `(' <param-list> `)' `[`'<communication-list>`]' \\
            <command>* \\
  `end def'
\end{grammar}

La lista de parametros \textit{param-list} es una lista de variables separadas por coma
que se inicializan cuando el actor es creado. La lista de comunicaciones (communication-list)
muchas veces depende del tipo de comunicación que se esté enviando, por ejemplo
si se está enviando un mensaje de \textbf{Retiro} a un actor simulando ser una
caja de ahorros la comunicación debe especificar la cantidad a retirar. Pero si
quiere saber cual es el \textbf{Balance} no debe especificar ningun parametro
adicional.
Basicamente se bifurca por el valor de uno de los campos llamado
\textbf{tag-field}, dependiendo de este diferentes identificarores son esperados.
La sintaxis de esta lista es la siguiente:

\begin{grammar}
  <params> ::= <id> | <id> `,' <params>
  <var-list> ::= `case' <tag-field> `of' <variant>+ `end case'
  <variant> ::= <case label> `:' <params>
\end{grammar}

El siguiente ejemplo muestra un caso donde es útil utilizar la sintaxis basada
en \textbf{case}:

\begin{verbatim}
case request of 
  depositar : (cliente, monto) 
  retirar: (cliente, monto) 
  balance: (cliente) 
end case
\end{verbatim}

En este caso \textbf{depositar}, \textbf{retirar} y \textbf{balance} son
simbolos. 
No siempre es necesario utilizar esta sintaxis, communication-list puede tener
la misma estructura que param-list.

\subsection{Ejemplo: cálculo de factorial en SAL}

SAL no tiene construcciones para control de flujo, pero esto se puede encodear
dentro como mensajes.

--- INCLUIR UNA IMAGEN DE COMO SE CALCULA EL FACTORIAL DE 3 ---

La implementación dada a continuación esta tomada de \cite{Agha:1986:AMC:7929}.

\begin{lstlisting}[language=sal, style=simple]
def Factorial()[val, customer]
  if val = 0 then
    send [1] to customer
  else
    let cont = new FactorialCont(val, customer)
       in send [val - 1, cont] to self
  end if
  become Factorial()
end def

def FactorialCont(n, customer)[arg] 
  send [n * arg] to customer
end def
\end{lstlisting}

Cuando \textbf{Factorial} recibe un mensaje esté incluye un entero positivo y
una referencia al actor al que el resultado debe ser enviado. Al recibir el
mensaje se comporta de la siguiente manera, si el valor que recibe es 0, le
envia a customer 1. En caso contrario, crea un nuevo actor
\textbf{FactorialCont} con los parametros, \textbf{val - 1} y \textbf{customer}.
Cuando eventualmente \textbf{FactorialCont} recibe un entero, le envia a
\textbf{Customer} la multiplicación de este por el valor que tenía originalmente
en parametro. Se puede ver en la figura como esto evoluciona para el calculo del
factorial de 3.

\section{CSP y actores}
Para empezar a describir como se modeló en CSP, primero es importante hacer
referencia a que se utilizó CSPm, que combina los operadores de CSP
originalmente propuesto por Hoare, y un lenguage funcional.

En el proceso de traducción de SAL a CSPm, fue necesario construir un pequeño
\textit{runtime} para emular como los actores corren. Recordemos que la
naturaleza de CSP es sincrona y los actores no lo son. Fue necesario
concretamente desacoplar el pedido de creación de los actores de la creación
misma, tambien el envio y la recepción de mensajes. 

\subsection{Creación de nuevos actores}

Para desacoplar la creación de actores se utilizan dos abstracciones,
\textbf{ActorID} y un par de canales que comunican, la intención de crear un
actor por parte de otro, y el momento en el que este actor es activado.Se
menciona activación y creción, dado que CSPm necesita conocer la red completa
de procesos involucrados al comienzo de la simulación fue necesario simular la creación.

Para definir \textbf{ActorID} utilizaremos tipos alegbraicos parecidos a los de haskell.

\begin{lstlisting}{language=CSPm, style=simple}
datatype ActorID = Factorial.{1} | FactorialWorker.{1,2,3} | Main.{1}
\end{lstlisting}

Este tipo introduce y nombra cada uno de los actores que van ser utilizados. Es
decir, no solo incluye el nombre, sino que la cantidad. Para esto se utiliza la
notacíon que se ve entre llaves, en este caso vamos a contar con un actor del
tipo \textbf{Factorial}, tres dle tipo \textbf{FactorialWorker} y uno más del
tipo \textbf{Main}.


\begin{lstlisting}{language=CSPm, style=simple}
channel CreateAsk:ActorID.(Value, Value)
channel Create:ActorID.(Value, Value)
\end{lstlisting}

Estos dos canales de CSP, son los encargados de desacoplar la creación,
\textbf{Value} es un tipo de datos representa los valores que pueden ser pasado
tanto en la creación de actores como en el envio de mensajes. Los valores a
utilizar son enteros, \textbf{ActorID} o \textbf{ATOMS}, este último se usa para
denominar un tipo de cadena de caracteres inmutable.

Ademas del actor que envia la intención de crear, y el que lo recibe finalmente,
existe un proceso auxiliar que comunica estas dos accciones.

\begin{lstlisting}{language=CSPm, style=simple}
CreateAsk!FactorialWorker.1?m -> Create.FactorialWorker.1!m -> STOP
CreateAsk!FactorialWorker.2?m -> Create.FactorialWorker.2!m -> STOP
CreateAsk!FactorialWorker.3?m -> Create.FactorialWorker.3!m -> STOP
\end{lstlisting}

Este proceso simplemente espera a sincronizar con un evento de tipo
\textit{CreateAsk} y emite un evento de tipo \textit{Create}.
En la semantica de CSP cuando utilizamos \textbf{`?'} estamos esperando un valor
por un canal, si utlizamos \textbf{`!'} estamos enviando.

En el ejemplo se puede ver que se envia el valor $FactorialWorker.1$ a quien esté
dispuesto a sincronizar, y se recepciona $m$ que equivale a la tupla de valores
antes vista. Luego se espera a sincronizar con $Create.FactorialWorker.1$ a
quien se le envía el valor de $m$.

Esto no desacopla la creción que sino que, al mismo tiempo, La asignación de un
único nombre al actor. En este caso es el valor que se envía mediante
$CreateAsk$.

\subsection{Envio de mensajes}
Para desacoplar el envío de mensajes utilizamos una estructura intermedia que
actua de \textit{mailbox}, para comunicarase con esta estructura existen dos canales.

\begin{lstlisting}{language=CSPm, style=simple}
channel CommSend:ActorID.(VALUE, VALUE)
channel CommRecv:ActorID.(VALUE, VALUE)
\end{lstlisting}

Un actor se bloquea esperando en $CommRecv$, cuando una nueva comunicación está
dispuesta a ser sincronizada, desde el mailbox hacia el actor, se procesa.
Generalmente la primera acción de cualquier actor es esperar la llegada de un
menasaje.

Un \textit{mailbox} puede guardar más de un mensaje en su interior. Esto
introduce un tipo de no determinismo, un actor puede sincronizar con cualquiera
de los mensajes disponibles en su \textit{mailbox}.

Por cada actor creado, existe un \textit{mailbox} con el mismo \textbf{ActorId}
asociado a este. 

\subsection{Definición de comportamientos}
La definición de comportamientos es quien utiliza las dos abstracciónes antes
mencionadas.
Para mostrar como funciona, se utilizará un ejemplo simple, un actor que cuando
es creado recive un parametro \textbf{ActorId}, luego se queda esperando un
mensaje, cuanado lo recive, utiliza el valor entero que recepciona, y lo
incrementa en uno y lo envia a la referencía del actor que recibió en el
momento de creación.

\begin{lstlisting}{language=CSPm, style=simple}
g = Create!G.1?(a1, None) -> g_running(G.1, a1) 
g_running(self, ACTOR.client) =
  CommRecv.self!(INT.v, None) ->
  CommSend.client!(add(v, SI.1), None) ->
  g_running(self, ACTOR.client)
\end{lstlisting}

Desarmando el ejemplo, una vez recibido el mensaje $Create!G.1?(a1, None)$,
podemos decir que el actor está \textit{Corriendo}. Para eso utilizamos la
funcíon $g\_running$. Cuando un comportamiento reacciona a un mensaje, tiene que
definir el comportamiento de reemplazo, en este caso puede ser el mismo
comportamiento que antes. Para esto tambien se utliza esta función, esto se
puede ver en la última linea del ejemplo, esta tambien podría haber sido $STOP$,
si no hubiera un nuevo comportamiento (botton behaviour).

$CommRecv$ espera en el mailbox \textit{self} que el mailbox que es el mailbox
propio al actor, cuando recibe el mesaje $CommSend.client$ Envia un evento al
mailbox de $client$ con la tupla $(add(v, SI.1), None)$. Como utilizamos una
represantación mas pequeña de los enteros para evitar //TODO: PROBLEMAS CON LOS
ENTEROS GRANDES. El proceso de \textit{mailbox} estará esperando sincronizar
la recepción con el evento $CommSend$ y lo guardará y esperara que el actor esté
disponible para sincronizar el evento $CommRecv$ que efectuará la entrega.

\subsection{Ejemplo: cálculo de factorial en CSPm}
Se utilizará el mismo ejemplo del factorial antes visto en sal \textbf{SAL},
está compuesto por dos comportamientos $Factorial$ y $FactorialWorker$.

\subsubsection*{Comporamiento de Factorial}

\begin{lstlisting}{language=CSPm, style=simple}
factorial = Create!Factorial.1?(None, None) -> factorialRunning(Factorial.1)
factorialRunning(self) = CommRecv?self.(ACTOR.mailboxClient, INT.k) ->
if (eq(k,SI.0))
  then
    CommSend!mailboxClient.(INT.SI.1, None) -> factorialRunning(self)
  else
    let
      newK = sub(k, SI.1)
    within
      CreateAsk?FactorialWorker.pid!(INT.k, ACTOR.mailboxClient) ->
      CommSend!self.(ACTOR.FactorialWorker.pid, INT.newK) ->
      factorialRunning(self)
\end{lstlisting}

El comportamiento del fragmento de código anterior, es exactamente lo mismo que
hace el código antes visto en SAL. Cuando recibe un mensaje, este contiene dos
parametros: el mailbox del cliente, y un entero K. Si este entero K fuera 0,
enviamos el valor uno al mailbox del cliente.
En caso contrario, crea un actor de tipo \textbf{FactorialWorker} y asigna su
mailbox a \textit{FactorialWorker.pid} le envia a este un mensaje con un valor
\textit{newK} que es basicamete $k-1$.
En ambos caso el comportamiento de reemplazo para el mailbox acutal, es el mismo
que antes.

\subsubsection*{Comporamiento de Worker}

\begin{lstlisting}{language=CSPm, style=simple}
factorialWorker  = ||| actorId : {|FactorialWorker|} @ Create!actorId?(k, mailboxClient) -> factorialWorkerRunning(actorId, k, mailboxClient)
factorialWorkerRunning(self, INT.k, ACTOR.mailboxClient) = CommRecv.self?(INT.n, None) ->
    let
      val = mult(n, k)
    within
      CommSend.mailboxClient!(INT.val, None) ->
      STOP
\end{lstlisting}

A diferencia del actor anterior, ya que en este caso necesitamos mas de un actor
del tipo \textbf{FactorialWorker}, en la primer linea puede verse que se
comienzan en paralelo utlizando el operador de interliving de $CSPm$ tantos
procesos como elementos existan \textbf{FactorialWorker}. //TODO: INCLUIR UN
EJEMPLO DE LA NOTACIÓN.

Utilziando esta notación el tipo de datos \textbf{ActorID}, tiene dos
responsabilidades: nombrar los actores y enumerarlos. Recordemos que es
necesario conocer la cantidad total de procesos que va a tener un red de $CSP$
antes de comenzar la simulación.

Este comportamiento es muy simple, en el momento de creación recibe dos
parametros, un entero k y un mailbox. En el momento de recibir un mensaje, este
toma el valor enviado en este mensaje lo multiplica y se lo envía a el mailbox
que recibio originalmente en el momento de creación.

No tiene comportamiento de reemplazo.

\subsection{Generalizando el ejemplo}

TODO: Definir \textbf{translateExp}

La clase \textbf{Cmnd} con elementos de tipo S está dada por:

\begin{verbatim}
S :== S_1 ; S_2 | if b then S_1 else S_2 | send [e1, .., e_i] to a | become new
E(e_1, .. ,e_i) | let a_1 = new E_1(e_1,..,e_i) and ... a_j = new
E_1(e_1,..,e_i) { S } 
\end{verbatim}

definimos la funcion \textbf{translateCmd} de la siguiente forma:

\begin{verbatim}
translateCmd (S_1 S_2) = translateCmd(S_1) -> translateCmd(S_2)
\end{verbatim}


\begin{verbatim}
translateCmd(if b then S_1 else S_2) = 
   if (translateExp(b)) then
       translateCmd(S_1) else 
       translateCmd(S_2)
\end{verbatim}

\begin{verbatim}
translateCmd(send[e_1, ..., e_i] to a) = CommSend.a.
         (translateExp(e_1), ..., 
          translateExp(e_i)) 
\end{verbatim}

\begin{verbatim}
translateCmd(become new Beh(e_1, ..., e_n)) = runningBeh(self, e_1, ..., e_n)
\end{verbatim}

newEnv es el resultado de agregar a el entorno de las variables de mailbox $a_1
= E_1.pid_1$ .. $a_n = E_n.pid_n$
\begin{verbatim}
translateCmd(let a_1 = new E_1(e_1, ..., e_j) and 
         ... and a_n = new E_N(e_1, ..., e_j) { S } = 

CreateAsk?E_1.pid_1!(translateExp(e_1), ...,translateExp(e_j)) ->
CreateAsk?E_N.pid_n!(translateExp(e_1), ...,translateExp(e_j)) ->
translateCmd(S, newEnv)
\end{verbatim}


La clase \textbf{Beha} con elementos de tipo S está dada por:

\begin{verbatim}
def behName(a_1 .. a_i)[n_1 ... n_j]
  S
end def
\end{verbatim}

Tendria como equivalente en CSP:

\begin{verbatim}

behName = ||| actorId : {|BehName|} @ Create.actorId?(a_1, ..., a_i) ->
behNameRunning(actorId, a_1, .., a_n)

behNameRunning(self, a_1, .., a_n) = CommRecv.self(n_1 ... n_j) -> translateCmd(S)

\end{verbatim}

--- Agregar case? ---


\bibliography{references}{}
\bibliographystyle{plain}
\end{document}

